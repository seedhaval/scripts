==============================
collections.ChainMap
(*maps)
A ChainMap groups multiple dicts (or other mappings) together
to create a single, updateable view.

The underlying mappings are stored in a list
 That list is public and can
be accessed or updated using the *maps* attribute
 There is no other
state.

Lookups search the underlying mappings successively until a key is found.
In contrast, writes, updates, and deletions only operate on the first
mapping.

==============================
collections.ChainMap.clear
(self)
Clear maps[0], leaving maps[1:] intact.

==============================
collections.ChainMap.copy
(self)
New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]

==============================
collections.ChainMap.fromkeys
(iterable, *args)
Create a ChainMap with a single dict created from the iterable.

==============================
collections.ChainMap.get
(self, key, default=None)
D.get(k[,d]) -> D[k] if k in D, else d
 d defaults to None.

==============================
collections.ChainMap.items
(self)
D.items() -> a set-like object providing a view on D's items

==============================
collections.ChainMap.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
collections.ChainMap.new_child
(self, m=None)
New ChainMap with a new map followed by all previous maps.
If no map is provided, an empty dict is used.

==============================
collections.ChainMap.parents
New ChainMap from maps[1:].

==============================
collections.ChainMap.pop
(self, key, *args)
Remove *key* from maps[0] and return its value
Raise KeyError if *key* not in maps[0].

==============================
collections.ChainMap.popitem
(self)
Remove and return an item pair from maps[0]
Raise KeyError is maps[0] is empty.

==============================
collections.ChainMap.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
collections.ChainMap.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
collections.ChainMap.values
(self)
D.values() -> an object providing a view on D's values

==============================
collections.Counter
(iterable=None, /, **kwds)
Dict subclass for counting hashable items
 Sometimes called a bag
or multiset
 Elements are stored as dictionary keys and their counts
are stored as dictionary values.

>>> c = Counter('abcdeabcdabcaba')  # count elements from a string

>>> c.most_common(3)                # three most common elements
[('a', 5), ('b', 4), ('c', 3)]
>>> sorted(c)                       # list all unique elements
['a', 'b', 'c', 'd', 'e']
>>> ''.join(sorted(c.elements()))   # list elements with repetitions
'aaaaabbbbcccdde'
>>> sum(c.values())                 # total of all counts
15

>>> c['a']                          # count of letter 'a'
5
>>> for elem in 'shazam':           # update counts from an iterable
..
    c[elem] += 1                # by adding 1 to each element's count
>>> c['a']                          # now there are seven 'a'
7
>>> del c['b']                      # remove all 'b'
>>> c['b']                          # now there are zero 'b'
0

>>> d = Counter('simsalabim')       # make another counter
>>> c.update(d)                     # add in the second counter
>>> c['a']                          # now there are nine 'a'
9

>>> c.clear()                       # empty the counter
>>> c
Counter()

Note:  If a count is set to zero or reduced to zero, it will remain
in the counter until the entry is deleted or the counter is cleared:

>>> c = Counter('aaabbc')
>>> c['b'] -= 2                     # reduce the count of 'b' by two
>>> c.most_common()                 # 'b' is still in, but its count is zero
[('a', 3), ('c', 1), ('b', 0)]

==============================
collections.Counter.clear
D.clear() -> None
 Remove all items from D.

==============================
collections.Counter.copy
(self)
Return a shallow copy.

==============================
collections.Counter.elements
(self)
Iterator over elements repeating each as many times as its count.

>>> c = Counter('ABCABC')
>>> sorted(c.elements())
['A', 'A', 'B', 'B', 'C', 'C']

# Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
>>> prime_factors = Counter({2: 2, 3: 3, 17: 1})
>>> product = 1
>>> for factor in prime_factors.elements():     # loop over factors
..
    product *= factor                       # and multiply them
>>> product
1836

Note, if an element's count has been set to zero or is a negative
number, elements() will ignore it.

==============================
collections.Counter.fromkeys
(iterable, v=None)
Create a new dictionary with keys from iterable and values set to value.

==============================
collections.Counter.get
(self, key, default=None, /)
Return the value for key if key is in the dictionary, else default.

==============================
collections.Counter.items
D.items() -> a set-like object providing a view on D's items

==============================
collections.Counter.keys
D.keys() -> a set-like object providing a view on D's keys

==============================
collections.Counter.most_common
(self, n=None)
List the n most common elements and their counts from the most
common to the least
 If n is None, then list all element counts.

>>> Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]

==============================
collections.Counter.pop
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised

==============================
collections.Counter.popitem
(self, /)
Remove and return a (key, value) pair as a 2-tuple.

Pairs are returned in LIFO (last-in, first-out) order.
Raises KeyError if the dict is empty.

==============================
collections.Counter.setdefault
(self, key, default=None, /)
Insert key with a value of default if key is not in the dictionary.

Return the value for key if key is in the dictionary, else default.

==============================
collections.Counter.subtract
(self, iterable=None, /, **kwds)
Like dict.update() but subtracts counts instead of replacing them.
Counts can be reduced below zero
 Both the inputs and outputs are
allowed to contain zero and negative counts.

Source can be an iterable, a dictionary, or another Counter instance.

>>> c = Counter('which')
>>> c.subtract('witch')             # subtract elements from another iterable
>>> c.subtract(Counter('watch'))    # subtract elements from another counter
>>> c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch
0
>>> c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch
-1

==============================
collections.Counter.update
(self, iterable=None, /, **kwds)
Like dict.update() but add counts instead of replacing them.

Source can be an iterable, a dictionary, or another Counter instance.

>>> c = Counter('which')
>>> c.update('witch')           # add elements from another iterable
>>> d = Counter('watch')
>>> c.update(d)                 # add elements from another counter
>>> c['h']                      # four 'h' in which, witch, and watch
4

==============================
collections.Counter.values
D.values() -> an object providing a view on D's values

==============================
collections.OrderedDict
Dictionary that remembers insertion order

==============================
collections.OrderedDict.clear
od.clear() -> None
 Remove all items from od.

==============================
collections.OrderedDict.copy
od.copy() -> a shallow copy of od

==============================
collections.OrderedDict.fromkeys
(iterable, value=None)
Create a new ordered dictionary with keys from iterable and values set to value.

==============================
collections.OrderedDict.get
(self, key, default=None, /)
Return the value for key if key is in the dictionary, else default.

==============================
collections.OrderedDict.items
D.items() -> a set-like object providing a view on D's items

==============================
collections.OrderedDict.keys
D.keys() -> a set-like object providing a view on D's keys

==============================
collections.OrderedDict.move_to_end
(self, /, key, last=True)
Move an existing element to the end (or beginning if last is false).

Raise KeyError if the element does not exist.

==============================
collections.OrderedDict.pop
od.pop(k[,d]) -> v, remove specified key and return the corresponding
value
 If key is not found, d is returned if given, otherwise KeyError
is raised.

==============================
collections.OrderedDict.popitem
(self, /, last=True)
Remove and return a (key, value) pair from the dictionary.

Pairs are returned in LIFO order if last is true or FIFO order if false.

==============================
collections.OrderedDict.setdefault
(self, /, key, default=None)
Insert key with a value of default if key is not in the dictionary.

Return the value for key if key is in the dictionary, else default.

==============================
collections.OrderedDict.update
D.update([E, ]**F) -> None
 Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]

==============================
collections.OrderedDict.values
D.values() -> an object providing a view on D's values

==============================
collections.UserDict
(dict=None, /, **kwargs)
None

==============================
collections.UserDict.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
collections.UserDict.copy
(self)
None

==============================
collections.UserDict.fromkeys
(iterable, value=None)
None

==============================
collections.UserDict.get
(self, key, default=None)
D.get(k[,d]) -> D[k] if k in D, else d
 d defaults to None.

==============================
collections.UserDict.items
(self)
D.items() -> a set-like object providing a view on D's items

==============================
collections.UserDict.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
collections.UserDict.pop
(self, key, default=<object object at 0x7fa09a968160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
collections.UserDict.popitem
(self)
D.popitem() -> (k, v), remove and return some (key, value) pair
as a 2-tuple; but raise KeyError if D is empty.

==============================
collections.UserDict.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
collections.UserDict.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
collections.UserDict.values
(self)
D.values() -> an object providing a view on D's values

==============================
collections.UserList
(initlist=None)
A more or less complete user-defined wrapper around list objects.

==============================
collections.UserList.append
(self, item)
S.append(value) -- append value to the end of the sequence

==============================
collections.UserList.clear
(self)
S.clear() -> None -- remove all items from S

==============================
collections.UserList.copy
(self)
None

==============================
collections.UserList.count
(self, item)
S.count(value) -> integer -- return number of occurrences of value

==============================
collections.UserList.extend
(self, other)
S.extend(iterable) -- extend sequence by appending elements from the iterable

==============================
collections.UserList.index
(self, item, *args)
S.index(value, [start, [stop]]) -> integer -- return first index of value.
Raises ValueError if the value is not present.

Supporting start and stop arguments is optional, but
recommended.

==============================
collections.UserList.insert
(self, i, item)
S.insert(index, value) -- insert value before index

==============================
collections.UserList.pop
(self, i=-1)
S.pop([index]) -> item -- remove and return item at index (default last).
Raise IndexError if list is empty or index is out of range.

==============================
collections.UserList.remove
(self, item)
S.remove(value) -- remove first occurrence of value.
Raise ValueError if the value is not present.

==============================
collections.UserList.reverse
(self)
S.reverse() -- reverse *IN PLACE*

==============================
collections.UserList.sort
(self, /, *args, **kwds)
None

==============================
collections.UserString
(seq)
All the operations on a read-only sequence.

Concrete subclasses must override __new__ or __init__,
__getitem__, and __len__.

==============================
collections.UserString.capitalize
(self)
None

==============================
collections.UserString.casefold
(self)
None

==============================
collections.UserString.center
(self, width, *args)
None

==============================
collections.UserString.count
(self, sub, start=0, end=9223372036854775807)
S.count(value) -> integer -- return number of occurrences of value

==============================
collections.UserString.encode
(self, encoding='utf-8', errors='strict')
None

==============================
collections.UserString.endswith
(self, suffix, start=0, end=9223372036854775807)
None

==============================
collections.UserString.expandtabs
(self, tabsize=8)
None

==============================
collections.UserString.find
(self, sub, start=0, end=9223372036854775807)
None

==============================
collections.UserString.format
(self, /, *args, **kwds)
None

==============================
collections.UserString.format_map
(self, mapping)
None

==============================
collections.UserString.index
(self, sub, start=0, end=9223372036854775807)
S.index(value, [start, [stop]]) -> integer -- return first index of value.
Raises ValueError if the value is not present.

Supporting start and stop arguments is optional, but
recommended.

==============================
collections.UserString.isalnum
(self)
None

==============================
collections.UserString.isalpha
(self)
None

==============================
collections.UserString.isascii
(self)
None

==============================
collections.UserString.isdecimal
(self)
None

==============================
collections.UserString.isdigit
(self)
None

==============================
collections.UserString.isidentifier
(self)
None

==============================
collections.UserString.islower
(self)
None

==============================
collections.UserString.isnumeric
(self)
None

==============================
collections.UserString.isprintable
(self)
None

==============================
collections.UserString.isspace
(self)
None

==============================
collections.UserString.istitle
(self)
None

==============================
collections.UserString.isupper
(self)
None

==============================
collections.UserString.join
(self, seq)
None

==============================
collections.UserString.ljust
(self, width, *args)
None

==============================
collections.UserString.lower
(self)
None

==============================
collections.UserString.lstrip
(self, chars=None)
None

==============================
collections.UserString.maketrans
Return a translation table usable for str.translate().

If there is only one argument, it must be a dictionary mapping Unicode
ordinals (integers) or characters to Unicode ordinals, strings or None.
Character keys will be then converted to ordinals.
If there are two arguments, they must be strings of equal length, and
in the resulting dictionary, each character in x will be mapped to the
character at the same position in y
If there is a third argument, it
must be a string, whose characters will be mapped to None in the result.

==============================
collections.UserString.partition
(self, sep)
None

==============================
collections.UserString.replace
(self, old, new, maxsplit=-1)
None

==============================
collections.UserString.rfind
(self, sub, start=0, end=9223372036854775807)
None

==============================
collections.UserString.rindex
(self, sub, start=0, end=9223372036854775807)
None

==============================
collections.UserString.rjust
(self, width, *args)
None

==============================
collections.UserString.rpartition
(self, sep)
None

==============================
collections.UserString.rsplit
(self, sep=None, maxsplit=-1)
None

==============================
collections.UserString.rstrip
(self, chars=None)
None

==============================
collections.UserString.split
(self, sep=None, maxsplit=-1)
None

==============================
collections.UserString.splitlines
(self, keepends=False)
None

==============================
collections.UserString.startswith
(self, prefix, start=0, end=9223372036854775807)
None

==============================
collections.UserString.strip
(self, chars=None)
None

==============================
collections.UserString.swapcase
(self)
None

==============================
collections.UserString.title
(self)
None

==============================
collections.UserString.translate
(self, *args)
None

==============================
collections.UserString.upper
(self)
None

==============================
collections.UserString.zfill
(self, width)
None

==============================
collections.abc
None

==============================
collections.defaultdict
defaultdict(default_factory[, ...]) --> dict with default factory

The default factory is called without arguments to produce
a new value when a key is not present, in __getitem__ only.
A defaultdict compares equal to a dict with the same items.
All remaining arguments are treated the same as if they were
passed to the dict constructor, including keyword arguments.

==============================
collections.defaultdict.clear
D.clear() -> None
 Remove all items from D.

==============================
collections.defaultdict.copy
D.copy() -> a shallow copy of D.

==============================
collections.defaultdict.default_factory
Factory for default value called by __missing__().

==============================
collections.defaultdict.fromkeys
(iterable, value=None, /)
Create a new dictionary with keys from iterable and values set to value.

==============================
collections.defaultdict.get
(self, key, default=None, /)
Return the value for key if key is in the dictionary, else default.

==============================
collections.defaultdict.items
D.items() -> a set-like object providing a view on D's items

==============================
collections.defaultdict.keys
D.keys() -> a set-like object providing a view on D's keys

==============================
collections.defaultdict.pop
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised

==============================
collections.defaultdict.popitem
(self, /)
Remove and return a (key, value) pair as a 2-tuple.

Pairs are returned in LIFO (last-in, first-out) order.
Raises KeyError if the dict is empty.

==============================
collections.defaultdict.setdefault
(self, key, default=None, /)
Insert key with a value of default if key is not in the dictionary.

Return the value for key if key is in the dictionary, else default.

==============================
collections.defaultdict.update
D.update([E, ]**F) -> None
 Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
In either case, this is followed by: for k in F:  D[k] = F[k]

==============================
collections.defaultdict.values
D.values() -> an object providing a view on D's values

==============================
collections.deque
deque([iterable[, maxlen]]) --> deque object

A list-like sequence optimized for data accesses near its endpoints.

==============================
collections.deque.append
Add an element to the right side of the deque.

==============================
collections.deque.appendleft
Add an element to the left side of the deque.

==============================
collections.deque.clear
Remove all elements from the deque.

==============================
collections.deque.copy
Return a shallow copy of a deque.

==============================
collections.deque.count
D.count(value) -> integer -- return number of occurrences of value

==============================
collections.deque.extend
Extend the right side of the deque with elements from the iterable

==============================
collections.deque.extendleft
Extend the left side of the deque with elements from the iterable

==============================
collections.deque.index
D.index(value, [start, [stop]]) -> integer -- return first index of value.
Raises ValueError if the value is not present.

==============================
collections.deque.insert
D.insert(index, object) -- insert object before index

==============================
collections.deque.maxlen
maximum size of a deque or None if unbounded

==============================
collections.deque.pop
Remove and return the rightmost element.

==============================
collections.deque.popleft
Remove and return the leftmost element.

==============================
collections.deque.remove
D.remove(value) -- remove first occurrence of value.

==============================
collections.deque.reverse
D.reverse() -- reverse *IN PLACE*

==============================
collections.deque.rotate
Rotate the deque n steps to the right (default n=1)
 If n is negative, rotates left.

==============================
collections.namedtuple
(typename, field_names, *, rename=False, defaults=None, module=None)
Returns a new subclass of tuple with named fields.

>>> Point = namedtuple('Point', ['x', 'y'])
>>> Point.__doc__                   # docstring for the new class
'Point(x, y)'
>>> p = Point(11, y=22)             # instantiate with positional args or keywords
>>> p[0] + p[1]                     # indexable like a plain tuple
33
>>> x, y = p                        # unpack like a regular tuple
>>> x, y
(11, 22)
>>> p.x + p.y                       # fields also accessible by name
33
>>> d = p._asdict()                 # convert to a dictionary
>>> d['x']
11
>>> Point(**d)                      # convert from a dictionary
Point(x=11, y=22)
>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
Point(x=100, y=22)

