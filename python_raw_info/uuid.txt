==============================
uuid.Enum
(value, names=None, *, module=None, qualname=None, type=None, start=1)
Generic enumeration.

Derive from this class to define new enumerations.

==============================
uuid.NAMESPACE_DNS
Instances of the UUID class represent UUIDs as specified in RFC 4122.
UUID objects are immutable, hashable, and usable as dictionary keys.
Converting a UUID to a string with str() yields something in the form
'12345678-1234-1234-1234-123456789abc'
 The UUID constructor accepts
five possible forms: a similar string of hexadecimal digits, or a tuple
of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
48-bit values respectively) as an argument named 'fields', or a string
of 16 bytes (with all the integer fields in big-endian order) as an
argument named 'bytes', or a string of 16 bytes (with the first three
fields in little-endian order) as an argument named 'bytes_le', or a
single 128-bit integer as an argument named 'int'.

UUIDs have these read-only attributes:

    bytes       the UUID as a 16-byte string (containing the six
                integer fields in big-endian byte order)

    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                and time_hi_version in little-endian byte order)

    fields      a tuple of the six integer fields of the UUID,
                which are also available as six individual attributes
                and two derived attributes:

        time_low                the first 32 bits of the UUID
        time_mid                the next 16 bits of the UUID
        time_hi_version         the next 16 bits of the UUID
        clock_seq_hi_variant    the next 8 bits of the UUID
        clock_seq_low           the next 8 bits of the UUID
        node                    the last 48 bits of the UUID

        time                    the 60-bit timestamp
        clock_seq               the 14-bit sequence number

    hex         the UUID as a 32-character hexadecimal string

    int         the UUID as a 128-bit integer

    urn         the UUID as a URN as specified in RFC 4122

    variant     the UUID variant (one of the constants RESERVED_NCS,
                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

    version     the UUID version number (1 through 5, meaningful only
                when the variant is RFC_4122)

    is_safe     An enum indicating whether the UUID has been generated in
                a way that is safe for multiprocessing applications, via
                uuid_generate_time_safe(3).

==============================
uuid.NAMESPACE_OID
Instances of the UUID class represent UUIDs as specified in RFC 4122.
UUID objects are immutable, hashable, and usable as dictionary keys.
Converting a UUID to a string with str() yields something in the form
'12345678-1234-1234-1234-123456789abc'
 The UUID constructor accepts
five possible forms: a similar string of hexadecimal digits, or a tuple
of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
48-bit values respectively) as an argument named 'fields', or a string
of 16 bytes (with all the integer fields in big-endian order) as an
argument named 'bytes', or a string of 16 bytes (with the first three
fields in little-endian order) as an argument named 'bytes_le', or a
single 128-bit integer as an argument named 'int'.

UUIDs have these read-only attributes:

    bytes       the UUID as a 16-byte string (containing the six
                integer fields in big-endian byte order)

    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                and time_hi_version in little-endian byte order)

    fields      a tuple of the six integer fields of the UUID,
                which are also available as six individual attributes
                and two derived attributes:

        time_low                the first 32 bits of the UUID
        time_mid                the next 16 bits of the UUID
        time_hi_version         the next 16 bits of the UUID
        clock_seq_hi_variant    the next 8 bits of the UUID
        clock_seq_low           the next 8 bits of the UUID
        node                    the last 48 bits of the UUID

        time                    the 60-bit timestamp
        clock_seq               the 14-bit sequence number

    hex         the UUID as a 32-character hexadecimal string

    int         the UUID as a 128-bit integer

    urn         the UUID as a URN as specified in RFC 4122

    variant     the UUID variant (one of the constants RESERVED_NCS,
                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

    version     the UUID version number (1 through 5, meaningful only
                when the variant is RFC_4122)

    is_safe     An enum indicating whether the UUID has been generated in
                a way that is safe for multiprocessing applications, via
                uuid_generate_time_safe(3).

==============================
uuid.NAMESPACE_URL
Instances of the UUID class represent UUIDs as specified in RFC 4122.
UUID objects are immutable, hashable, and usable as dictionary keys.
Converting a UUID to a string with str() yields something in the form
'12345678-1234-1234-1234-123456789abc'
 The UUID constructor accepts
five possible forms: a similar string of hexadecimal digits, or a tuple
of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
48-bit values respectively) as an argument named 'fields', or a string
of 16 bytes (with all the integer fields in big-endian order) as an
argument named 'bytes', or a string of 16 bytes (with the first three
fields in little-endian order) as an argument named 'bytes_le', or a
single 128-bit integer as an argument named 'int'.

UUIDs have these read-only attributes:

    bytes       the UUID as a 16-byte string (containing the six
                integer fields in big-endian byte order)

    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                and time_hi_version in little-endian byte order)

    fields      a tuple of the six integer fields of the UUID,
                which are also available as six individual attributes
                and two derived attributes:

        time_low                the first 32 bits of the UUID
        time_mid                the next 16 bits of the UUID
        time_hi_version         the next 16 bits of the UUID
        clock_seq_hi_variant    the next 8 bits of the UUID
        clock_seq_low           the next 8 bits of the UUID
        node                    the last 48 bits of the UUID

        time                    the 60-bit timestamp
        clock_seq               the 14-bit sequence number

    hex         the UUID as a 32-character hexadecimal string

    int         the UUID as a 128-bit integer

    urn         the UUID as a URN as specified in RFC 4122

    variant     the UUID variant (one of the constants RESERVED_NCS,
                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

    version     the UUID version number (1 through 5, meaningful only
                when the variant is RFC_4122)

    is_safe     An enum indicating whether the UUID has been generated in
                a way that is safe for multiprocessing applications, via
                uuid_generate_time_safe(3).

==============================
uuid.NAMESPACE_X500
Instances of the UUID class represent UUIDs as specified in RFC 4122.
UUID objects are immutable, hashable, and usable as dictionary keys.
Converting a UUID to a string with str() yields something in the form
'12345678-1234-1234-1234-123456789abc'
 The UUID constructor accepts
five possible forms: a similar string of hexadecimal digits, or a tuple
of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
48-bit values respectively) as an argument named 'fields', or a string
of 16 bytes (with all the integer fields in big-endian order) as an
argument named 'bytes', or a string of 16 bytes (with the first three
fields in little-endian order) as an argument named 'bytes_le', or a
single 128-bit integer as an argument named 'int'.

UUIDs have these read-only attributes:

    bytes       the UUID as a 16-byte string (containing the six
                integer fields in big-endian byte order)

    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                and time_hi_version in little-endian byte order)

    fields      a tuple of the six integer fields of the UUID,
                which are also available as six individual attributes
                and two derived attributes:

        time_low                the first 32 bits of the UUID
        time_mid                the next 16 bits of the UUID
        time_hi_version         the next 16 bits of the UUID
        clock_seq_hi_variant    the next 8 bits of the UUID
        clock_seq_low           the next 8 bits of the UUID
        node                    the last 48 bits of the UUID

        time                    the 60-bit timestamp
        clock_seq               the 14-bit sequence number

    hex         the UUID as a 32-character hexadecimal string

    int         the UUID as a 128-bit integer

    urn         the UUID as a URN as specified in RFC 4122

    variant     the UUID variant (one of the constants RESERVED_NCS,
                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

    version     the UUID version number (1 through 5, meaningful only
                when the variant is RFC_4122)

    is_safe     An enum indicating whether the UUID has been generated in
                a way that is safe for multiprocessing applications, via
                uuid_generate_time_safe(3).

==============================
uuid.RESERVED_FUTURE
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
uuid.RESERVED_MICROSOFT
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
uuid.RESERVED_NCS
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
uuid.RFC_4122
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
uuid.SafeUUID
(value, names=None, *, module=None, qualname=None, type=None, start=1)
An enumeration.

==============================
uuid.SafeUUID.name
The name of the Enum member.

==============================
uuid.SafeUUID.safe
An enumeration.

==============================
uuid.SafeUUID.unknown
An enumeration.

==============================
uuid.SafeUUID.unsafe
An enumeration.

==============================
uuid.SafeUUID.value
The value of the Enum member.

==============================
uuid.UUID
(hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=<SafeUUID.unknown: None>)
Instances of the UUID class represent UUIDs as specified in RFC 4122.
UUID objects are immutable, hashable, and usable as dictionary keys.
Converting a UUID to a string with str() yields something in the form
'12345678-1234-1234-1234-123456789abc'
 The UUID constructor accepts
five possible forms: a similar string of hexadecimal digits, or a tuple
of six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and
48-bit values respectively) as an argument named 'fields', or a string
of 16 bytes (with all the integer fields in big-endian order) as an
argument named 'bytes', or a string of 16 bytes (with the first three
fields in little-endian order) as an argument named 'bytes_le', or a
single 128-bit integer as an argument named 'int'.

UUIDs have these read-only attributes:

    bytes       the UUID as a 16-byte string (containing the six
                integer fields in big-endian byte order)

    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,
                and time_hi_version in little-endian byte order)

    fields      a tuple of the six integer fields of the UUID,
                which are also available as six individual attributes
                and two derived attributes:

        time_low                the first 32 bits of the UUID
        time_mid                the next 16 bits of the UUID
        time_hi_version         the next 16 bits of the UUID
        clock_seq_hi_variant    the next 8 bits of the UUID
        clock_seq_low           the next 8 bits of the UUID
        node                    the last 48 bits of the UUID

        time                    the 60-bit timestamp
        clock_seq               the 14-bit sequence number

    hex         the UUID as a 32-character hexadecimal string

    int         the UUID as a 128-bit integer

    urn         the UUID as a URN as specified in RFC 4122

    variant     the UUID variant (one of the constants RESERVED_NCS,
                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)

    version     the UUID version number (1 through 5, meaningful only
                when the variant is RFC_4122)

    is_safe     An enum indicating whether the UUID has been generated in
                a way that is safe for multiprocessing applications, via
                uuid_generate_time_safe(3).

==============================
uuid.UUID.bytes
None

==============================
uuid.UUID.bytes_le
None

==============================
uuid.UUID.clock_seq
None

==============================
uuid.UUID.clock_seq_hi_variant
None

==============================
uuid.UUID.clock_seq_low
None

==============================
uuid.UUID.fields
None

==============================
uuid.UUID.hex
None

==============================
uuid.UUID.int
None

==============================
uuid.UUID.is_safe
None

==============================
uuid.UUID.node
None

==============================
uuid.UUID.time
None

==============================
uuid.UUID.time_hi_version
None

==============================
uuid.UUID.time_low
None

==============================
uuid.UUID.time_mid
None

==============================
uuid.UUID.urn
None

==============================
uuid.UUID.variant
None

==============================
uuid.UUID.version
None

==============================
uuid.bytes_
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
uuid.bytes_.capitalize
B.capitalize() -> copy of B

Return a copy of B with only its first character capitalized (ASCII)
and the rest lower-cased.

==============================
uuid.bytes_.center
(self, width, fillchar=b' ', /)
Return a centered string of length width.

Padding is done using the specified fill character.

==============================
uuid.bytes_.count
B.count(sub[, start[, end]]) -> int

Return the number of non-overlapping occurrences of subsection sub in
bytes B[start:end]
 Optional arguments start and end are interpreted
as in slice notation.

==============================
uuid.bytes_.decode
(self, /, encoding='utf-8', errors='strict')
Decode the bytes using the codec registered for encoding.

encoding
  The encoding with which to decode the bytes.
errors
  The error handling scheme to use for the handling of decoding errors.
  The default is 'strict' meaning that decoding errors raise a
  UnicodeDecodeError
Other possible values are 'ignore' and 'replace'
  as well as any other name registered with codecs.register_error that
  can handle UnicodeDecodeErrors.

==============================
uuid.bytes_.endswith
B.endswith(suffix[, start[, end]]) -> bool

Return True if B ends with the specified suffix, False otherwise.
With optional start, test B beginning at that position.
With optional end, stop comparing B at that position.
suffix can also be a tuple of bytes to try.

==============================
uuid.bytes_.expandtabs
(self, /, tabsize=8)
Return a copy where all tab characters are expanded using spaces.

If tabsize is not given, a tab size of 8 characters is assumed.

==============================
uuid.bytes_.find
B.find(sub[, start[, end]]) -> int

Return the lowest index in B where subsection sub is found,
such that sub is contained within B[start,end]
 Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.

==============================
uuid.bytes_.fromhex
(string, /)
Create a bytes object from a string of hexadecimal numbers.

Spaces between two numbers are accepted.
Example: bytes.fromhex('B9 01EF') -> b'\\xb9\\x01\\xef'.

==============================
uuid.bytes_.hex
Create a str of hexadecimal numbers from a bytes object.

  sep
    An optional single character or byte to separate hex bytes.
  bytes_per_sep
    How many bytes between separators
 Positive values count from the
    right, negative values count from the left.

Example:
>>> value = b'\xb9\x01\xef'
>>> value.hex()
'b901ef'
>>> value.hex(':')
'b9:01:ef'
>>> value.hex(':', 2)
'b9:01ef'
>>> value.hex(':', -2)
'b901:ef'

==============================
uuid.bytes_.index
B.index(sub[, start[, end]]) -> int

Return the lowest index in B where subsection sub is found,
such that sub is contained within B[start,end]
 Optional
arguments start and end are interpreted as in slice notation.

Raises ValueError when the subsection is not found.

==============================
uuid.bytes_.isalnum
B.isalnum() -> bool

Return True if all characters in B are alphanumeric
and there is at least one character in B, False otherwise.

==============================
uuid.bytes_.isalpha
B.isalpha() -> bool

Return True if all characters in B are alphabetic
and there is at least one character in B, False otherwise.

==============================
uuid.bytes_.isascii
B.isascii() -> bool

Return True if B is empty or all characters in B are ASCII,
False otherwise.

==============================
uuid.bytes_.isdigit
B.isdigit() -> bool

Return True if all characters in B are digits
and there is at least one character in B, False otherwise.

==============================
uuid.bytes_.islower
B.islower() -> bool

Return True if all cased characters in B are lowercase and there is
at least one cased character in B, False otherwise.

==============================
uuid.bytes_.isspace
B.isspace() -> bool

Return True if all characters in B are whitespace
and there is at least one character in B, False otherwise.

==============================
uuid.bytes_.istitle
B.istitle() -> bool

Return True if B is a titlecased string and there is at least one
character in B, i.e
uppercase characters may only follow uncased
characters and lowercase characters only cased ones
Return False
otherwise.

==============================
uuid.bytes_.isupper
B.isupper() -> bool

Return True if all cased characters in B are uppercase and there is
at least one cased character in B, False otherwise.

==============================
uuid.bytes_.join
(self, iterable_of_bytes, /)
Concatenate any number of bytes objects.

The bytes whose method is called is inserted in between each pair.

The result is returned as a new bytes object.

Example: b'.'.join([b'ab', b'pq', b'rs']) -> b'ab.pq.rs'.

==============================
uuid.bytes_.ljust
(self, width, fillchar=b' ', /)
Return a left-justified string of length width.

Padding is done using the specified fill character.

==============================
uuid.bytes_.lower
B.lower() -> copy of B

Return a copy of B with all ASCII characters converted to lowercase.

==============================
uuid.bytes_.lstrip
(self, bytes=None, /)
Strip leading bytes contained in the argument.

If the argument is omitted or None, strip leading  ASCII whitespace.

==============================
uuid.bytes_.maketrans
(frm, to, /)
Return a translation table useable for the bytes or bytearray translate method.

The returned table will be one where each byte in frm is mapped to the byte at
the same position in to.

The bytes objects frm and to must be of the same length.

==============================
uuid.bytes_.partition
(self, sep, /)
Partition the bytes into three parts using the given separator.

This will search for the separator sep in the bytes
If the separator is found,
returns a 3-tuple containing the part before the separator, the separator
itself, and the part after it.

If the separator is not found, returns a 3-tuple containing the original bytes
object and two empty bytes objects.

==============================
uuid.bytes_.replace
(self, old, new, count=-1, /)
Return a copy with all occurrences of substring old replaced by new.

  count
    Maximum number of occurrences to replace.
    -1 (the default value) means replace all occurrences.

If the optional argument count is given, only the first count occurrences are
replaced.

==============================
uuid.bytes_.rfind
B.rfind(sub[, start[, end]]) -> int

Return the highest index in B where subsection sub is found,
such that sub is contained within B[start,end]
 Optional
arguments start and end are interpreted as in slice notation.

Return -1 on failure.

==============================
uuid.bytes_.rindex
B.rindex(sub[, start[, end]]) -> int

Return the highest index in B where subsection sub is found,
such that sub is contained within B[start,end]
 Optional
arguments start and end are interpreted as in slice notation.

Raise ValueError when the subsection is not found.

==============================
uuid.bytes_.rjust
(self, width, fillchar=b' ', /)
Return a right-justified string of length width.

Padding is done using the specified fill character.

==============================
uuid.bytes_.rpartition
(self, sep, /)
Partition the bytes into three parts using the given separator.

This will search for the separator sep in the bytes, starting at the end
If
the separator is found, returns a 3-tuple containing the part before the
separator, the separator itself, and the part after it.

If the separator is not found, returns a 3-tuple containing two empty bytes
objects and the original bytes object.

==============================
uuid.bytes_.rsplit
(self, /, sep=None, maxsplit=-1)
Return a list of the sections in the bytes, using sep as the delimiter.

  sep
    The delimiter according which to split the bytes.
    None (the default value) means split on ASCII whitespace characters
    (space, tab, return, newline, formfeed, vertical tab).
  maxsplit
    Maximum number of splits to do.
    -1 (the default value) means no limit.

Splitting is done starting at the end of the bytes and working to the front.

==============================
uuid.bytes_.rstrip
(self, bytes=None, /)
Strip trailing bytes contained in the argument.

If the argument is omitted or None, strip trailing ASCII whitespace.

==============================
uuid.bytes_.split
(self, /, sep=None, maxsplit=-1)
Return a list of the sections in the bytes, using sep as the delimiter.

sep
  The delimiter according which to split the bytes.
  None (the default value) means split on ASCII whitespace characters
  (space, tab, return, newline, formfeed, vertical tab).
maxsplit
  Maximum number of splits to do.
  -1 (the default value) means no limit.

==============================
uuid.bytes_.splitlines
(self, /, keepends=False)
Return a list of the lines in the bytes, breaking at line boundaries.

Line breaks are not included in the resulting list unless keepends is given and
true.

==============================
uuid.bytes_.startswith
B.startswith(prefix[, start[, end]]) -> bool

Return True if B starts with the specified prefix, False otherwise.
With optional start, test B beginning at that position.
With optional end, stop comparing B at that position.
prefix can also be a tuple of bytes to try.

==============================
uuid.bytes_.strip
(self, bytes=None, /)
Strip leading and trailing bytes contained in the argument.

If the argument is omitted or None, strip leading and trailing ASCII whitespace.

==============================
uuid.bytes_.swapcase
B.swapcase() -> copy of B

Return a copy of B with uppercase ASCII characters converted
to lowercase ASCII and vice versa.

==============================
uuid.bytes_.title
B.title() -> copy of B

Return a titlecased version of B, i.e
ASCII words start with uppercase
characters, all remaining cased characters have lowercase.

==============================
uuid.bytes_.translate
(self, table, /, delete=b'')
Return a copy with each character mapped by the given translation table.

  table
    Translation table, which must be a bytes object of length 256.

All characters occurring in the optional argument delete are removed.
The remaining characters are mapped through the given translation table.

==============================
uuid.bytes_.upper
B.upper() -> copy of B

Return a copy of B with all ASCII characters converted to uppercase.

==============================
uuid.bytes_.zfill
(self, width, /)
Pad a numeric string with zeros on the left, to fill a field of the given width.

The original string is never truncated.

==============================
uuid.getnode
(*, getters=None)
Get the hardware address as a 48-bit positive integer.

The first time this runs, it may launch a separate program, which could
be quite slow
 If all attempts to obtain the hardware address fail, we
choose a random 48-bit number with its eighth bit set to 1 as recommended
in RFC 4122.

==============================
uuid.int_
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
uuid.int_.as_integer_ratio
(self, /)
Return integer ratio.

Return a pair of integers, whose ratio is exactly equal to the original int
and with a positive denominator.

>>> (10).as_integer_ratio()
(10, 1)
>>> (-10).as_integer_ratio()
(-10, 1)
>>> (0).as_integer_ratio()
(0, 1)

==============================
uuid.int_.bit_length
(self, /)
Number of bits necessary to represent self in binary.

>>> bin(37)
'0b100101'
>>> (37).bit_length()
6

==============================
uuid.int_.conjugate
Returns self, the complex conjugate of any int.

==============================
uuid.int_.denominator
the denominator of a rational number in lowest terms

==============================
uuid.int_.from_bytes
(bytes, byteorder, *, signed=False)
Return the integer represented by the given array of bytes.

bytes
  Holds the array of bytes to convert
 The argument must either
  support the buffer protocol or be an iterable object producing bytes.
  Bytes and bytearray are examples of built-in objects that support the
  buffer protocol.
byteorder
  The byte order used to represent the integer
 If byteorder is 'big',
  the most significant byte is at the beginning of the byte array
 If
  byteorder is 'little', the most significant byte is at the end of the
  byte array
 To request the native byte order of the host system, use
  `sys.byteorder' as the byte order value.
signed
  Indicates whether two's complement is used to represent the integer.

==============================
uuid.int_.imag
the imaginary part of a complex number

==============================
uuid.int_.numerator
the numerator of a rational number in lowest terms

==============================
uuid.int_.real
the real part of a complex number

==============================
uuid.int_.to_bytes
(self, /, length, byteorder, *, signed=False)
Return an array of bytes representing an integer.

length
  Length of bytes object to use
 An OverflowError is raised if the
  integer is not representable with the given number of bytes.
byteorder
  The byte order used to represent the integer
 If byteorder is 'big',
  the most significant byte is at the beginning of the byte array
 If
  byteorder is 'little', the most significant byte is at the end of the
  byte array
 To request the native byte order of the host system, use
  `sys.byteorder' as the byte order value.
signed
  Determines whether two's complement is used to represent the integer.
  If signed is False and a negative integer is given, an OverflowError
  is raised.

==============================
uuid.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
uuid.platform
This module tries to retrieve as much platform-identifying data as
possible
It makes this information available via function APIs.

If called from the command line, it prints the platform
information concatenated as single string to stdout
The output
format is useable as part of a filename.

==============================
uuid.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
uuid.uuid1
(node=None, clock_seq=None)
Generate a UUID from a host ID, sequence number, and the current time.
If 'node' is not given, getnode() is used to obtain the hardware
address
 If 'clock_seq' is given, it is used as the sequence number;
otherwise a random 14-bit sequence number is chosen.

==============================
uuid.uuid3
(namespace, name)
Generate a UUID from the MD5 hash of a namespace UUID and a name.

==============================
uuid.uuid4
()
Generate a random UUID.

==============================
uuid.uuid5
(namespace, name)
Generate a UUID from the SHA-1 hash of a namespace UUID and a name.

