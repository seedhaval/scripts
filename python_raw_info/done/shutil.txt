shutil.chown
(path, user=None, group=None)
Change owner user and group of the given path.
user and group can be the uid/gid or the user/group names, and in that case,
they are converted to their respective uid/gid.
==============================
shutil.copy
(src, dst, *, follow_symlinks=True)
Copy data and mode bits ("cp src dst")
Return the file's destination.
The destination may be a directory.
==============================
shutil.copy2
(src, dst, *, follow_symlinks=True)
Copy data and metadata
Return the file's destination.
Metadata is copied with copystat()
The destination may be a directory.
==============================
shutil.copyfile
(src, dst, *, follow_symlinks=True)
Copy data from src to dst in the most efficient way possible.
==============================
shutil.copyfileobj
(fsrc, fdst, length=0)
copy data from file-like object fsrc to file-like object fdst
==============================
shutil.copymode
(src, dst, *, follow_symlinks=True)
Copy mode bits from src to dst.
Linux) this method does nothing.
==============================
shutil.copystat
(src, dst, *, follow_symlinks=True)
Copy file metadata
Copy the permission bits, last access time, last modification time, and flags from `src` to `dst`
The file contents, owner, and group are unaffected
==============================
shutil.copytree
(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x7f764669b280>, ignore_dangling_symlinks=False, dirs_exist_ok=False)
Recursively copy a directory tree and return the destination directory.
dirs_exist_ok dictates whether to raise an exception in case dst or any missing parent directory already exists.
The optional ignore argument is a callable If given, it is called with the `src` parameter, which is the directory being visited by copytree(), and `names` which is the list of `src` contents, as returned by os.listdir(): callable(src, names) -> ignored_names
The optional copy_function argument is a callable that will be used to copy each file It will be called with the source path and the destination path as arguments
By default, copy2() is used, but any function that supports the same signature (like copy()) can be used.
==============================
shutil.disk_usage
(path)
Return disk usage statistics about the given path.
Returned value is a named tuple with attributes 'total', 'used' and 'free', which are the amount of total, used and free space, in bytes.
==============================
shutil.fnmatch
Filename matching with shell patterns.
fnmatch(FILENAME, PATTERN) matches according to the local convention.
fnmatchcase(FILENAME, PATTERN) always takes case in account.
==============================
shutil.get_archive_formats
()
Returns a list of supported formats for archiving and unarchiving.
Each element of the returned sequence is a tuple (name, description)
==============================
shutil.get_terminal_size
(fallback=(80, 24))
Get the size of the terminal window.
Fallback defaults to (80, 24) which is the default size used by many terminal emulators.
The value returned is a named tuple of type os.terminal_size.
==============================
shutil.getgrnam
(name)
Return the group database entry for the given group name.
==============================
shutil.getpwnam
(name, /)
Return the password database entry for the given user name.
==============================
shutil.ignore_patterns
(*patterns)
Function that can be used as copytree() ignore parameter.
Patterns is a sequence of glob-style patterns that are used to exclude files
==============================
shutil.make_archive
(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)
Create an archive file (eg zip or tar).
'base_name' is the name of the file to create, minus any format-specific extension;
'format' is the archive format: one of "zip", "tar", "gztar", "bztar", or "xztar" Or any other registered format.
'root_dir' is a directory that will be the root directory of the archive; ie we typically chdir into 'root_dir' before creating the archive
 'base_dir' is the directory where we start archiving from; ie 'base_dir' will be the common prefix of all files and directories in the archive
 'root_dir' and 'base_dir' both default to the current directory
 Returns the name of the archive file.
'owner' and 'group' are used when creating a tar archive
By default, uses the current owner and group.
==============================
shutil.move
(src, dst, copy_function=<function copy2 at 0x7f764669b280>)
Recursively move a file or directory to another location
This is similar to the Unix "mv" command
Return the file or directory's destination.
The destination path must not already exist.
The optional `copy_function` argument is a callable that will be used to copy the source or it will be delegated to `copytree`.
By default, copy2() is used, but any function that supports the same signature (like copy()) can be used.
==============================
shutil.rmtree
(path, ignore_errors=False, onerror=None)
Recursively delete a directory tree.
If ignore_errors is set, errors are ignored; otherwise, if onerror is set, it is called to handle the error with arguments (func, path, exc_info) where func is platform and implementation dependent; path is the argument to that function that caused it to fail; and exc_info is a tuple returned by sys.exc_info()
==============================
shutil.unpack_archive
(filename, extract_dir=None, format=None)
Unpack an archive.
`filename` is the name of the archive.
`extract_dir` is the name of the target directory, where the archive is unpacked
If not provided, the current working directory is used.
`format` is the archive format: one of "zip", "tar", "gztar", "bztar", or "xztar"
==============================
shutil.which
(cmd, mode=1, path=None)
Given a command, mode, and a PATH string, return the path which conforms to the given mode on the PATH, or None if there is no such file.
`mode` defaults to os.F_OK | os.X_OK
`path` defaults to the result of os.environ.get("PATH"), or can be overridden with a custom search path.
