==============================
subprocess.CalledProcessError
(returncode, cmd, output=None, stderr=None)
Raised when run() is called with check=True and the process
returns a non-zero exit status.

Attributes:
  cmd, returncode, stdout, stderr, output

==============================
subprocess.CalledProcessError.args
None

==============================
subprocess.CalledProcessError.stdout
Alias for output attribute, to match stderr

==============================
subprocess.CalledProcessError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
subprocess.CompletedProcess
(args, returncode, stdout=None, stderr=None)
A process that has finished running.

This is returned by run().

Attributes:
  args: The list or str args passed to run().
  returncode: The exit code of the process, negative for signals.
  stdout: The standard output (None if not captured).
  stderr: The standard error (None if not captured).

==============================
subprocess.CompletedProcess.check_returncode
(self)
Raise CalledProcessError if the exit code is non-zero.

==============================
subprocess.DEVNULL
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
subprocess.PIPE
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
subprocess.Popen
(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None, text=None)
Execute a child program in a new process.

For a complete description of the arguments see the Python documentation.

Arguments:
  args: A string, or a sequence of program arguments.

  bufsize: supplied as the buffering argument to the open() function when
      creating the stdin/stdout/stderr pipe file objects

  executable: A replacement program to execute.

  stdin, stdout and stderr: These specify the executed programs' standard
      input, standard output and standard error file handles, respectively.

  preexec_fn: (POSIX only) An object to be called in the child process
      just before the child is executed.

  close_fds: Controls closing or inheriting of file descriptors.

  shell: If true, the command will be executed through the shell.

  cwd: Sets the current directory before the child is executed.

  env: Defines the environment variables for the new process.

  text: If true, decode stdin, stdout and stderr using the given encoding
      (if set) or the system default otherwise.

  universal_newlines: Alias of text, provided for backwards compatibility.

  startupinfo and creationflags (Windows only)

  restore_signals (POSIX only)

  start_new_session (POSIX only)

  pass_fds (POSIX only)

  encoding and errors: Text mode encoding and error handling to use for
      file objects stdin, stdout and stderr.

Attributes:
    stdin, stdout, stderr, pid, returncode

==============================
subprocess.Popen.communicate
(self, input=None, timeout=None)
Interact with process: Send data to stdin and close it.
Read data from stdout and stderr, until end-of-file is
reached
 Wait for process to terminate.

The optional "input" argument should be data to be sent to the
child process, or None, if no data should be sent to the child.
communicate() returns a tuple (stdout, stderr).

By default, all communication is in bytes, and therefore any
"input" should be bytes, and the (stdout, stderr) will be bytes.
If in text mode (indicated by self.text_mode), any "input" should
be a string, and (stdout, stderr) will be strings decoded
according to locale encoding, or by "encoding" if set
Text mode
is triggered by setting any of text, encoding, errors or
universal_newlines.

==============================
subprocess.Popen.kill
(self)
Kill the process with SIGKILL
            

==============================
subprocess.Popen.poll
(self)
Check if child process has terminated
Set and return returncode
attribute.

==============================
subprocess.Popen.send_signal
(self, sig)
Send a signal to the process.

==============================
subprocess.Popen.terminate
(self)
Terminate the process with SIGTERM
            

==============================
subprocess.Popen.universal_newlines
None

==============================
subprocess.Popen.wait
(self, timeout=None)
Wait for child process to terminate; returns self.returncode.

==============================
subprocess.STDOUT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
subprocess.SubprocessError
Common base class for all non-exit exceptions.

==============================
subprocess.SubprocessError.args
None

==============================
subprocess.SubprocessError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
subprocess.TimeoutExpired
(cmd, timeout, output=None, stderr=None)
This exception is raised when the timeout expires while waiting for a
child process.

Attributes:
    cmd, output, stdout, stderr, timeout

==============================
subprocess.TimeoutExpired.args
None

==============================
subprocess.TimeoutExpired.stdout
None

==============================
subprocess.TimeoutExpired.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
subprocess.builtins
Built-in functions, exceptions, and other objects.

Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices.

==============================
subprocess.call
(*popenargs, timeout=None, **kwargs)
Run command with arguments
 Wait for command to complete or
timeout, then return the returncode attribute.

The arguments are the same as for the Popen constructor
 Example:

retcode = call(["ls", "-l"])

==============================
subprocess.check_call
(*popenargs, **kwargs)
Run command with arguments
 Wait for command to complete
 If
the exit code was zero then return, otherwise raise
CalledProcessError
 The CalledProcessError object will have the
return code in the returncode attribute.

The arguments are the same as for the call function
 Example:

check_call(["ls", "-l"])

==============================
subprocess.check_output
(*popenargs, timeout=None, **kwargs)
Run command with arguments and return its output.

If the exit code was non-zero it raises a CalledProcessError
 The
CalledProcessError object will have the return code in the returncode
attribute and output in the output attribute.

The arguments are the same as for the Popen constructor
 Example:

>>> check_output(["ls", "-l", "/dev/null"])
b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'

The stdout argument is not allowed as it is used internally.
To capture standard error in the result, use stderr=STDOUT.

>>> check_output(["/bin/sh", "-c",
..
              "ls -l non_existent_file ; exit 0"],
..
             stderr=STDOUT)
b'ls: non_existent_file: No such file or directory\n'

There is an additional optional argument, "input", allowing you to
pass a string to the subprocess's stdin
 If you use this argument
you may not also use the Popen constructor's "stdin" argument, as
it too will be used internally
 Example:

>>> check_output(["sed", "-e", "s/foo/bar/"],
..
             input=b"when in the course of fooman events\n")
b'when in the course of barman events\n'

By default, all communication is in bytes, and therefore any "input"
should be bytes, and the return value will be bytes
 If in text mode,
any "input" should be a string, and the return value will be a string
decoded according to locale encoding, or by "encoding" if set
Text mode
is triggered by setting any of text, encoding, errors or universal_newlines.

==============================
subprocess.contextlib
Utilities for with-statement contexts
 See PEP 343.

==============================
subprocess.errno
This module makes available standard errno system symbols.

The value of each symbol is the corresponding integer value,
e.g., on most systems, errno.ENOENT equals the integer 2.

The dictionary errno.errorcode maps numeric codes to symbol names,
e.g., errno.errorcode[2] could be the string 'ENOENT'.

Symbols that are not relevant to the underlying system are not defined.

To map error codes to error messages, use the function os.strerror(),
e.g
os.strerror(2) could return 'No such file or directory'.

==============================
subprocess.getoutput
(cmd)
Return output (stdout or stderr) of executing cmd in a shell.

Like getstatusoutput(), except the exit status is ignored and the return
value is a string containing the command's output
 Example:

>>> import subprocess
>>> subprocess.getoutput('ls /bin/ls')
'/bin/ls'

==============================
subprocess.getstatusoutput
(cmd)
Return (exitcode, output) of executing cmd in a shell.

Execute the string 'cmd' in a shell with 'check_output' and
return a 2-tuple (status, output)
The locale encoding is used
to decode the output and process newlines.

A trailing newline is stripped from the output.
The exit status for the command can be interpreted
according to the rules for the function 'wait'
Example:

>>> import subprocess
>>> subprocess.getstatusoutput('ls /bin/ls')
(0, '/bin/ls')
>>> subprocess.getstatusoutput('cat /bin/junk')
(1, 'cat: /bin/junk: No such file or directory')
>>> subprocess.getstatusoutput('/bin/junk')
(127, 'sh: /bin/junk: not found')
>>> subprocess.getstatusoutput('/bin/kill $$')
(-15, '')

==============================
subprocess.io
The io module provides the Python interfaces to stream handling
The
builtin open function is defined in this module.

At the top of the I/O hierarchy is the abstract base class IOBase
It
defines the basic interface to a stream
Note, however, that there is no
separation between reading and writing to streams; implementations are
allowed to raise an OSError if they do not support a given operation.

Extending IOBase is RawIOBase which deals simply with the reading and
writing of raw bytes to a stream
FileIO subclasses RawIOBase to provide
an interface to OS files.

BufferedIOBase deals with buffering on a raw byte stream (RawIOBase)
Its
subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer
streams that are readable, writable, and both respectively.
BufferedRandom provides a buffered interface to random access
streams
BytesIO is a simple stream of in-memory bytes.

Another IOBase subclass, TextIOBase, deals with the encoding and decoding
of streams into text
TextIOWrapper, which extends it, is a buffered text
interface to a buffered raw stream (`BufferedIOBase`)
Finally, StringIO
is an in-memory stream for text.

Argument names are not part of the specification, and only the arguments
of open() are intended to be used as keyword arguments.

data:

DEFAULT_BUFFER_SIZE

   An int containing the default buffer size used by the module's buffered
   I/O classes
open() uses the file's blksize (as obtained by os.stat) if
   possible.

==============================
subprocess.list2cmdline
(seq)
Translate a sequence of arguments into a command line
string, using the same rules as the MS C runtime:

1) Arguments are delimited by white space, which is either a
   space or a tab.

2) A string surrounded by double quotation marks is
   interpreted as a single argument, regardless of white space
   contained within
 A quoted string can be embedded in an
   argument.

3) A double quotation mark preceded by a backslash is
   interpreted as a literal double quotation mark.

4) Backslashes are interpreted literally, unless they
   immediately precede a double quotation mark.

5) If backslashes immediately precede a double quotation mark,
   every pair of backslashes is interpreted as a literal
   backslash
 If the number of backslashes is odd, the last
   backslash escapes the next double quotation mark as
   described in rule 3.

==============================
subprocess.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
subprocess.run
(*popenargs, input=None, capture_output=False, timeout=None, check=False, **kwargs)
Run command with arguments and return a CompletedProcess instance.

The returned instance will have attributes args, returncode, stdout and
stderr
By default, stdout and stderr are not captured, and those attributes
will be None
Pass stdout=PIPE and/or stderr=PIPE in order to capture them.

If check is True and the exit code was non-zero, it raises a
CalledProcessError
The CalledProcessError object will have the return code
in the returncode attribute, and output & stderr attributes if those streams
were captured.

If timeout is given, and the process takes too long, a TimeoutExpired
exception will be raised.

There is an optional argument "input", allowing you to
pass bytes or a string to the subprocess's stdin
 If you use this argument
you may not also use the Popen constructor's "stdin" argument, as
it will be used internally.

By default, all communication is in bytes, and therefore any "input" should
be bytes, and the stdout and stderr will be bytes
If in text mode, any
"input" should be a string, and stdout and stderr will be strings decoded
according to locale encoding, or by "encoding" if set
Text mode is
triggered by setting any of text, encoding, errors or universal_newlines.

The other arguments are the same as for the Popen constructor.

==============================
subprocess.select
This module supports asynchronous I/O on multiple file descriptors.

*** IMPORTANT NOTICE ***
On Windows, only sockets are supported; on Unix, all file descriptors.

==============================
subprocess.selectors
Selectors module.

This module allows high-level and efficient I/O multiplexing, built upon the
`select` module primitives.

==============================
subprocess.signal
None

==============================
subprocess.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
subprocess.threading
Thread module emulating a subset of Java's threading model.

==============================
subprocess.time
This module provides various functions to manipulate time values.

There are two standard representations of time
 One is the number
of seconds since the Epoch, in UTC (a.k.a
GMT)
 It may be an integer
or a floating point number (to represent fractions of seconds).
The Epoch is system-defined; on Unix, it is generally January 1st, 1970.
The actual value can be retrieved by calling gmtime(0).

The other representation is a tuple of 9 integers giving local time.
The tuple items are:
  year (including century, e.g
1998)
  month (1-12)
  day (1-31)
  hours (0-23)
  minutes (0-59)
  seconds (0-59)
  weekday (0-6, Monday is 0)
  Julian day (day in the year, 1-366)
  DST (Daylight Savings Time) flag (-1, 0 or 1)
If the DST flag is 0, the time is given in the regular time zone;
if it is 1, the time is given in the DST time zone;
if it is -1, mktime() should guess based on the date and time.

==============================
subprocess.warnings
Python part of the warnings subsystem.

