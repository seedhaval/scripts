==============================
zipfile.BZIP2_VERSION
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.BadZipFile
Common base class for all non-exit exceptions.

==============================
zipfile.BadZipFile.args
None

==============================
zipfile.BadZipFile.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
zipfile.BadZipfile
Common base class for all non-exit exceptions.

==============================
zipfile.BadZipfile.args
None

==============================
zipfile.BadZipfile.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
zipfile.CompleteDirs
(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)
A ZipFile subclass that ensures that implied directories
are always included in the namelist.

==============================
zipfile.CompleteDirs.close
(self)
Close the file, and for mode 'w', 'x' and 'a' write the ending
records.

==============================
zipfile.CompleteDirs.comment
The comment text associated with the ZIP file.

==============================
zipfile.CompleteDirs.extract
(self, member, path=None, pwd=None)
Extract a member from the archive to the current working directory,
using its full name
Its file information is extracted as accurately
as possible
`member' may be a filename or a ZipInfo object
You can
specify a different directory using `path'.

==============================
zipfile.CompleteDirs.extractall
(self, path=None, members=None, pwd=None)
Extract all members from the archive to the current working
directory
`path' specifies a different directory to extract to.
`members' is optional and must be a subset of the list returned
by namelist().

==============================
zipfile.CompleteDirs.fp
None

==============================
zipfile.CompleteDirs.getinfo
(self, name)
Return the instance of ZipInfo given 'name'.

==============================
zipfile.CompleteDirs.infolist
(self)
Return a list of class ZipInfo instances for files in the
archive.

==============================
zipfile.CompleteDirs.make
(source)
Given a source (filename or zipfile), return an
appropriate CompleteDirs subclass.

==============================
zipfile.CompleteDirs.namelist
(self)
Return a list of file names in the archive.

==============================
zipfile.CompleteDirs.open
(self, name, mode='r', pwd=None, *, force_zip64=False)
Return file-like object for 'name'.

name is a string for the file name within the ZIP file, or a ZipInfo
object.

mode should be 'r' to read a file already in the ZIP file, or 'w' to
write to a file newly added to the archive.

pwd is the password to decrypt files (only used for reading).

When writing, if the file size is not known in advance but may exceed
2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
files
 If the size is known in advance, it is best to pass a ZipInfo
instance for name, with zinfo.file_size set.

==============================
zipfile.CompleteDirs.printdir
(self, file=None)
Print a table of contents for the zip file.

==============================
zipfile.CompleteDirs.read
(self, name, pwd=None)
Return file bytes for name.

==============================
zipfile.CompleteDirs.resolve_dir
(self, name)
If the name represents a directory, return that name
as a directory (with the trailing slash).

==============================
zipfile.CompleteDirs.setpassword
(self, pwd)
Set default password for encrypted files.

==============================
zipfile.CompleteDirs.testzip
(self)
Read all the files and check the CRC.

==============================
zipfile.CompleteDirs.write
(self, filename, arcname=None, compress_type=None, compresslevel=None)
Put the bytes from filename into the archive under the name
arcname.

==============================
zipfile.CompleteDirs.writestr
(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)
Write a file into the archive
 The contents is 'data', which
may be either a 'str' or a 'bytes' instance; if it is a 'str',
it is encoded as UTF-8 first.
'zinfo_or_arcname' is either a ZipInfo instance or
the name of the file in the archive.

==============================
zipfile.DEFAULT_VERSION
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.FastLookup
(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)
ZipFile subclass to ensure implicit
dirs exist and are resolved rapidly.

==============================
zipfile.FastLookup.close
(self)
Close the file, and for mode 'w', 'x' and 'a' write the ending
records.

==============================
zipfile.FastLookup.comment
The comment text associated with the ZIP file.

==============================
zipfile.FastLookup.extract
(self, member, path=None, pwd=None)
Extract a member from the archive to the current working directory,
using its full name
Its file information is extracted as accurately
as possible
`member' may be a filename or a ZipInfo object
You can
specify a different directory using `path'.

==============================
zipfile.FastLookup.extractall
(self, path=None, members=None, pwd=None)
Extract all members from the archive to the current working
directory
`path' specifies a different directory to extract to.
`members' is optional and must be a subset of the list returned
by namelist().

==============================
zipfile.FastLookup.fp
None

==============================
zipfile.FastLookup.getinfo
(self, name)
Return the instance of ZipInfo given 'name'.

==============================
zipfile.FastLookup.infolist
(self)
Return a list of class ZipInfo instances for files in the
archive.

==============================
zipfile.FastLookup.make
(source)
Given a source (filename or zipfile), return an
appropriate CompleteDirs subclass.

==============================
zipfile.FastLookup.namelist
(self)
Return a list of file names in the archive.

==============================
zipfile.FastLookup.open
(self, name, mode='r', pwd=None, *, force_zip64=False)
Return file-like object for 'name'.

name is a string for the file name within the ZIP file, or a ZipInfo
object.

mode should be 'r' to read a file already in the ZIP file, or 'w' to
write to a file newly added to the archive.

pwd is the password to decrypt files (only used for reading).

When writing, if the file size is not known in advance but may exceed
2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
files
 If the size is known in advance, it is best to pass a ZipInfo
instance for name, with zinfo.file_size set.

==============================
zipfile.FastLookup.printdir
(self, file=None)
Print a table of contents for the zip file.

==============================
zipfile.FastLookup.read
(self, name, pwd=None)
Return file bytes for name.

==============================
zipfile.FastLookup.resolve_dir
(self, name)
If the name represents a directory, return that name
as a directory (with the trailing slash).

==============================
zipfile.FastLookup.setpassword
(self, pwd)
Set default password for encrypted files.

==============================
zipfile.FastLookup.testzip
(self)
Read all the files and check the CRC.

==============================
zipfile.FastLookup.write
(self, filename, arcname=None, compress_type=None, compresslevel=None)
Put the bytes from filename into the archive under the name
arcname.

==============================
zipfile.FastLookup.writestr
(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)
Write a file into the archive
 The contents is 'data', which
may be either a 'str' or a 'bytes' instance; if it is a 'str',
it is encoded as UTF-8 first.
'zinfo_or_arcname' is either a ZipInfo instance or
the name of the file in the archive.

==============================
zipfile.LZMACompressor
()
None

==============================
zipfile.LZMACompressor.compress
(self, data)
None

==============================
zipfile.LZMACompressor.flush
(self)
None

==============================
zipfile.LZMADecompressor
()
None

==============================
zipfile.LZMADecompressor.decompress
(self, data)
None

==============================
zipfile.LZMA_VERSION
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.LargeZipFile
Raised when writing a zipfile, the zipfile requires ZIP64 extensions
and those extensions are disabled.

==============================
zipfile.LargeZipFile.args
None

==============================
zipfile.LargeZipFile.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
zipfile.MAX_EXTRACT_VERSION
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.Path
(root, at='')
A pathlib-compatible interface for zip files.

Consider a zip file with this structure::

    .
    ├── a.txt
    └── b
        ├── c.txt
        └── d
            └── e.txt

>>> data = io.BytesIO()
>>> zf = ZipFile(data, 'w')
>>> zf.writestr('a.txt', 'content of a')
>>> zf.writestr('b/c.txt', 'content of c')
>>> zf.writestr('b/d/e.txt', 'content of e')
>>> zf.filename = 'abcde.zip'

Path accepts the zipfile object itself or a filename

>>> root = Path(zf)

From there, several path operations are available.

Directory iteration (including the zip file itself):

>>> a, b = root.iterdir()
>>> a
Path('abcde.zip', 'a.txt')
>>> b
Path('abcde.zip', 'b/')

name property:

>>> b.name
'b'

join with divide operator:

>>> c = b / 'c.txt'
>>> c
Path('abcde.zip', 'b/c.txt')
>>> c.name
'c.txt'

Read text:

>>> c.read_text()
'content of c'

existence:

>>> c.exists()
True
>>> (b / 'missing.txt').exists()
False

Coercion to string:

>>> str(c)
'abcde.zip/b/c.txt'

==============================
zipfile.Path.exists
(self)
None

==============================
zipfile.Path.is_dir
(self)
None

==============================
zipfile.Path.is_file
(self)
None

==============================
zipfile.Path.iterdir
(self)
None

==============================
zipfile.Path.joinpath
(self, add)
None

==============================
zipfile.Path.name
None

==============================
zipfile.Path.open
None

==============================
zipfile.Path.parent
None

==============================
zipfile.Path.read_bytes
(self)
None

==============================
zipfile.Path.read_text
(self, *args, **kwargs)
None

==============================
zipfile.PyZipFile
(file, mode='r', compression=0, allowZip64=True, optimize=-1)
Class to create ZIP archives with Python library files and packages.

==============================
zipfile.PyZipFile.close
(self)
Close the file, and for mode 'w', 'x' and 'a' write the ending
records.

==============================
zipfile.PyZipFile.comment
The comment text associated with the ZIP file.

==============================
zipfile.PyZipFile.extract
(self, member, path=None, pwd=None)
Extract a member from the archive to the current working directory,
using its full name
Its file information is extracted as accurately
as possible
`member' may be a filename or a ZipInfo object
You can
specify a different directory using `path'.

==============================
zipfile.PyZipFile.extractall
(self, path=None, members=None, pwd=None)
Extract all members from the archive to the current working
directory
`path' specifies a different directory to extract to.
`members' is optional and must be a subset of the list returned
by namelist().

==============================
zipfile.PyZipFile.fp
None

==============================
zipfile.PyZipFile.getinfo
(self, name)
Return the instance of ZipInfo given 'name'.

==============================
zipfile.PyZipFile.infolist
(self)
Return a list of class ZipInfo instances for files in the
archive.

==============================
zipfile.PyZipFile.namelist
(self)
Return a list of file names in the archive.

==============================
zipfile.PyZipFile.open
(self, name, mode='r', pwd=None, *, force_zip64=False)
Return file-like object for 'name'.

name is a string for the file name within the ZIP file, or a ZipInfo
object.

mode should be 'r' to read a file already in the ZIP file, or 'w' to
write to a file newly added to the archive.

pwd is the password to decrypt files (only used for reading).

When writing, if the file size is not known in advance but may exceed
2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
files
 If the size is known in advance, it is best to pass a ZipInfo
instance for name, with zinfo.file_size set.

==============================
zipfile.PyZipFile.printdir
(self, file=None)
Print a table of contents for the zip file.

==============================
zipfile.PyZipFile.read
(self, name, pwd=None)
Return file bytes for name.

==============================
zipfile.PyZipFile.setpassword
(self, pwd)
Set default password for encrypted files.

==============================
zipfile.PyZipFile.testzip
(self)
Read all the files and check the CRC.

==============================
zipfile.PyZipFile.write
(self, filename, arcname=None, compress_type=None, compresslevel=None)
Put the bytes from filename into the archive under the name
arcname.

==============================
zipfile.PyZipFile.writepy
(self, pathname, basename='', filterfunc=None)
Add all files from "pathname" to the ZIP archive.

If pathname is a package directory, search the directory and
all package subdirectories recursively for all *.py and enter
the modules into the archive
 If pathname is a plain
directory, listdir *.py and enter all modules
 Else, pathname
must be a Python *.py file and the module will be put into the
archive
 Added modules are always module.pyc.
This method will compile the module.py into module.pyc if
necessary.
If filterfunc(pathname) is given, it is called with every argument.
When it is False, the file or directory is skipped.

==============================
zipfile.PyZipFile.writestr
(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)
Write a file into the archive
 The contents is 'data', which
may be either a 'str' or a 'bytes' instance; if it is a 'str',
it is encoded as UTF-8 first.
'zinfo_or_arcname' is either a ZipInfo instance or
the name of the file in the archive.

==============================
zipfile.ZIP64_LIMIT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP64_VERSION
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP_BZIP2
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP_DEFLATED
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP_FILECOUNT_LIMIT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP_LZMA
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP_MAX_COMMENT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZIP_STORED
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZipExtFile
(fileobj, mode, zipinfo, pwd=None, close_fileobj=False)
File-like object for reading an archive member.
Is returned by ZipFile.open().

==============================
zipfile.ZipExtFile.MAX_N
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZipExtFile.MAX_SEEK_READ
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZipExtFile.MIN_READ_SIZE
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.ZipExtFile.close
(self)
Flush and close the IO object.

This method has no effect if the file is already closed.

==============================
zipfile.ZipExtFile.closed
None

==============================
zipfile.ZipExtFile.detach
(self, /)
Disconnect this buffer from its underlying raw stream and return it.

After the raw stream has been detached, the buffer is in an unusable
state.

==============================
zipfile.ZipExtFile.fileno
(self, /)
Returns underlying file descriptor if one exists.

OSError is raised if the IO object does not use a file descriptor.

==============================
zipfile.ZipExtFile.flush
(self, /)
Flush write buffers, if applicable.

This is not implemented for read-only and non-blocking streams.

==============================
zipfile.ZipExtFile.isatty
(self, /)
Return whether this is an 'interactive' stream.

Return False if it can't be determined.

==============================
zipfile.ZipExtFile.peek
(self, n=1)
Returns buffered bytes without advancing the position.

==============================
zipfile.ZipExtFile.read
(self, n=-1)
Read and return up to n bytes.
If the argument is omitted, None, or negative, data is read and returned until EOF is reached.

==============================
zipfile.ZipExtFile.read1
(self, n)
Read up to n bytes with at most one read() system call.

==============================
zipfile.ZipExtFile.readable
(self)
Return whether object was opened for reading.

If False, read() will raise OSError.

==============================
zipfile.ZipExtFile.readinto
(self, buffer, /)
None

==============================
zipfile.ZipExtFile.readinto1
(self, buffer, /)
None

==============================
zipfile.ZipExtFile.readline
(self, limit=-1)
Read and return a line from the stream.

If limit is specified, at most limit bytes will be read.

==============================
zipfile.ZipExtFile.readlines
(self, hint=-1, /)
Return a list of lines from the stream.

hint can be specified to control the number of lines read: no more
lines will be read if the total size (in bytes/characters) of all
lines so far exceeds hint.

==============================
zipfile.ZipExtFile.seek
(self, offset, whence=0)
Change stream position.

Change the stream position to the given byte offset
The offset is
interpreted relative to the position indicated by whence
 Values
for whence are:

* 0 -- start of stream (the default); offset should be zero or positive
* 1 -- current stream position; offset may be negative
* 2 -- end of stream; offset is usually negative

Return the new absolute position.

==============================
zipfile.ZipExtFile.seekable
(self)
Return whether object supports random access.

If False, seek(), tell() and truncate() will raise OSError.
This method may need to do a test seek().

==============================
zipfile.ZipExtFile.tell
(self)
Return current stream position.

==============================
zipfile.ZipExtFile.truncate
Truncate file to size bytes.

File pointer is left unchanged
 Size defaults to the current IO
position as reported by tell()
 Returns the new size.

==============================
zipfile.ZipExtFile.writable
(self, /)
Return whether object was opened for writing.

If False, write() will raise OSError.

==============================
zipfile.ZipExtFile.write
Write the given buffer to the IO stream.

Returns the number of bytes written, which is always the length of b
in bytes.

Raises BlockingIOError if the buffer is full and the
underlying raw stream cannot accept more data at the moment.

==============================
zipfile.ZipExtFile.writelines
(self, lines, /)
Write a list of lines to stream.

Line separators are not added, so it is usual for each of the
lines provided to have a line separator at the end.

==============================
zipfile.ZipFile
(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)
Class with methods to open, read, write, close, list zip files.

z = ZipFile(file, mode="r", compression=ZIP_STORED, allowZip64=True,
            compresslevel=None)

file: Either the path to the file, or a file-like object.
      If it is a path, the file will be opened and closed by ZipFile.
mode: The mode can be either read 'r', write 'w', exclusive create 'x',
      or append 'a'.
compression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),
             ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).
allowZip64: if True ZipFile will create files with ZIP64 extensions when
            needed, otherwise it will raise an exception when this would
            be necessary.
compresslevel: None (default for the given compression type) or an integer
               specifying the level to pass to the compressor.
               When using ZIP_STORED or ZIP_LZMA this keyword has no effect.
               When using ZIP_DEFLATED integers 0 through 9 are accepted.
               When using ZIP_BZIP2 integers 1 through 9 are accepted.

==============================
zipfile.ZipFile.close
(self)
Close the file, and for mode 'w', 'x' and 'a' write the ending
records.

==============================
zipfile.ZipFile.comment
The comment text associated with the ZIP file.

==============================
zipfile.ZipFile.extract
(self, member, path=None, pwd=None)
Extract a member from the archive to the current working directory,
using its full name
Its file information is extracted as accurately
as possible
`member' may be a filename or a ZipInfo object
You can
specify a different directory using `path'.

==============================
zipfile.ZipFile.extractall
(self, path=None, members=None, pwd=None)
Extract all members from the archive to the current working
directory
`path' specifies a different directory to extract to.
`members' is optional and must be a subset of the list returned
by namelist().

==============================
zipfile.ZipFile.fp
None

==============================
zipfile.ZipFile.getinfo
(self, name)
Return the instance of ZipInfo given 'name'.

==============================
zipfile.ZipFile.infolist
(self)
Return a list of class ZipInfo instances for files in the
archive.

==============================
zipfile.ZipFile.namelist
(self)
Return a list of file names in the archive.

==============================
zipfile.ZipFile.open
(self, name, mode='r', pwd=None, *, force_zip64=False)
Return file-like object for 'name'.

name is a string for the file name within the ZIP file, or a ZipInfo
object.

mode should be 'r' to read a file already in the ZIP file, or 'w' to
write to a file newly added to the archive.

pwd is the password to decrypt files (only used for reading).

When writing, if the file size is not known in advance but may exceed
2 GiB, pass force_zip64 to use the ZIP64 format, which can handle large
files
 If the size is known in advance, it is best to pass a ZipInfo
instance for name, with zinfo.file_size set.

==============================
zipfile.ZipFile.printdir
(self, file=None)
Print a table of contents for the zip file.

==============================
zipfile.ZipFile.read
(self, name, pwd=None)
Return file bytes for name.

==============================
zipfile.ZipFile.setpassword
(self, pwd)
Set default password for encrypted files.

==============================
zipfile.ZipFile.testzip
(self)
Read all the files and check the CRC.

==============================
zipfile.ZipFile.write
(self, filename, arcname=None, compress_type=None, compresslevel=None)
Put the bytes from filename into the archive under the name
arcname.

==============================
zipfile.ZipFile.writestr
(self, zinfo_or_arcname, data, compress_type=None, compresslevel=None)
Write a file into the archive
 The contents is 'data', which
may be either a 'str' or a 'bytes' instance; if it is a 'str',
it is encoded as UTF-8 first.
'zinfo_or_arcname' is either a ZipInfo instance or
the name of the file in the archive.

==============================
zipfile.ZipInfo
(filename='NoName', date_time=(1980, 1, 1, 0, 0, 0))
Class with attributes describing each file in the ZIP archive.

==============================
zipfile.ZipInfo.CRC
None

==============================
zipfile.ZipInfo.FileHeader
(self, zip64=None)
Return the per-file header as a bytes object.

==============================
zipfile.ZipInfo.comment
None

==============================
zipfile.ZipInfo.compress_size
None

==============================
zipfile.ZipInfo.compress_type
None

==============================
zipfile.ZipInfo.create_system
None

==============================
zipfile.ZipInfo.create_version
None

==============================
zipfile.ZipInfo.date_time
None

==============================
zipfile.ZipInfo.external_attr
None

==============================
zipfile.ZipInfo.extra
None

==============================
zipfile.ZipInfo.extract_version
None

==============================
zipfile.ZipInfo.file_size
None

==============================
zipfile.ZipInfo.filename
None

==============================
zipfile.ZipInfo.flag_bits
None

==============================
zipfile.ZipInfo.from_file
(filename, arcname=None, *, strict_timestamps=True)
Construct an appropriate ZipInfo for a file on the filesystem.

filename should be the path to a file or directory on the filesystem.

arcname is the name which it will have within the archive (by default,
this will be the same as filename, but without a drive letter and with
leading path separators removed).

==============================
zipfile.ZipInfo.header_offset
None

==============================
zipfile.ZipInfo.internal_attr
None

==============================
zipfile.ZipInfo.is_dir
(self)
Return True if this archive member is a directory.

==============================
zipfile.ZipInfo.orig_filename
None

==============================
zipfile.ZipInfo.reserved
None

==============================
zipfile.ZipInfo.volume
None

==============================
zipfile.binascii
Conversion between binary data and ASCII

==============================
zipfile.bz2
Interface to the libbzip2 compression library.

This module provides a file interface, classes for incremental
(de)compression, and functions for one-shot (de)compression.

==============================
zipfile.compressor_names
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
zipfile.contextlib
Utilities for with-statement contexts
 See PEP 343.

==============================
zipfile.crc32
(data, value=0, /)
Compute a CRC-32 checksum of data.

  value
    Starting value of the checksum.

The returned checksum is an integer.

==============================
zipfile.error
Common base class for all non-exit exceptions.

==============================
zipfile.error.args
None

==============================
zipfile.error.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
zipfile.functools
functools.py - Tools for working with functions and callable objects

==============================
zipfile.importlib
A pure Python implementation of import.

==============================
zipfile.io
The io module provides the Python interfaces to stream handling
The
builtin open function is defined in this module.

At the top of the I/O hierarchy is the abstract base class IOBase
It
defines the basic interface to a stream
Note, however, that there is no
separation between reading and writing to streams; implementations are
allowed to raise an OSError if they do not support a given operation.

Extending IOBase is RawIOBase which deals simply with the reading and
writing of raw bytes to a stream
FileIO subclasses RawIOBase to provide
an interface to OS files.

BufferedIOBase deals with buffering on a raw byte stream (RawIOBase)
Its
subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer
streams that are readable, writable, and both respectively.
BufferedRandom provides a buffered interface to random access
streams
BytesIO is a simple stream of in-memory bytes.

Another IOBase subclass, TextIOBase, deals with the encoding and decoding
of streams into text
TextIOWrapper, which extends it, is a buffered text
interface to a buffered raw stream (`BufferedIOBase`)
Finally, StringIO
is an in-memory stream for text.

Argument names are not part of the specification, and only the arguments
of open() are intended to be used as keyword arguments.

data:

DEFAULT_BUFFER_SIZE

   An int containing the default buffer size used by the module's buffered
   I/O classes
open() uses the file's blksize (as obtained by os.stat) if
   possible.

==============================
zipfile.is_zipfile
(filename)
Quickly see if a file is a ZIP file by checking the magic number.

The filename argument may be a file or file-like object too.

==============================
zipfile.itertools
Functional tools for creating and using iterators.

Infinite iterators:
count(start=0, step=1) --> start, start+step, start+2*step, ...
cycle(p) --> p0, p1, ..
plast, p0, p1, ...
repeat(elem [,n]) --> elem, elem, elem, ..
endlessly or up to n times

Iterators terminating on the shortest input sequence:
accumulate(p[, func]) --> p0, p0+p1, p0+p1+p2
chain(p, q, ...) --> p0, p1, ..
plast, q0, q1, ...
chain.from_iterable([p, q, ...]) --> p0, p1, ..
plast, q0, q1, ...
compress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...
dropwhile(pred, seq) --> seq[n], seq[n+1], starting when pred fails
groupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)
filterfalse(pred, seq) --> elements of seq where pred(elem) is False
islice(seq, [start,] stop [, step]) --> elements from
       seq[start:stop:step]
starmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...
tee(it, n=2) --> (it1, it2 , ..
itn) splits one iterator into n
takewhile(pred, seq) --> seq[0], seq[1], until pred fails
zip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ...

Combinatoric generators:
product(p, q, ..
[repeat=1]) --> cartesian product
permutations(p[, r])
combinations(p, r)
combinations_with_replacement(p, r)

==============================
zipfile.lzma
Interface to the liblzma compression library.

This module provides a class for reading and writing compressed files,
classes for incremental (de)compression, and convenience functions for
one-shot (de)compression.

These classes and functions support both the XZ and legacy LZMA
container formats, as well as raw compressed data streams.

==============================
zipfile.main
(args=None)
None

==============================
zipfile.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
zipfile.posixpath
Common operations on Posix pathnames.

Instead of importing this module directly, import os and refer to
this module as os.path
 The "os.path" name is an alias for this
module on Posix systems; on other systems (e.g
Windows),
os.path provides the same operations in a manner specific to that
platform, and is an alias to another module (e.g
ntpath).

Some of this can actually be useful on non-Posix systems too, e.g.
for manipulation of the pathname component of URLs.

==============================
zipfile.shutil
Utility functions for copying and archiving files and directory trees.

XXX The functions here don't copy the resource fork or other metadata on Mac.

==============================
zipfile.sizeCentralDir
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.sizeEndCentDir
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.sizeEndCentDir64
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.sizeEndCentDir64Locator
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.sizeFileHeader
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
zipfile.stat
Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *

==============================
zipfile.stringCentralDir
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
zipfile.stringEndArchive
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
zipfile.stringEndArchive64
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
zipfile.stringEndArchive64Locator
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
zipfile.stringFileHeader
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
zipfile.struct
Functions to convert between Python values and C structs.
Python bytes objects are used to hold the data representing the C struct
and also as format strings (explained below) to describe the layout of data
in the C struct.

The optional first format char indicates byte order, size and alignment:
  @: native order, size & alignment (default)
  =: native order, std
size & alignment
  <: little-endian, std
size & alignment
  >: big-endian, std
size & alignment
  !: same as >

The remaining chars indicate types of args and must match exactly;
these can be preceded by a decimal repeat count:
  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;
  ?: _Bool (requires C99; if not available, char is used instead)
  h:short; H:unsigned short; i:int; I:unsigned int;
  l:long; L:unsigned long; f:float; d:double; e:half-float.
Special cases (preceding decimal count indicates length):
  s:string (array of char); p: pascal string (with count byte).
Special cases (only available in native format):
  n:ssize_t; N:size_t;
  P:an integer type that is wide enough to hold a pointer.
Special case (not in native mode unless 'long long' in platform C):
  q:long long; Q:unsigned long long
Whitespace between formats is ignored.

The variable struct.error is an exception raised on errors.

==============================
zipfile.structCentralDir
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
zipfile.structEndArchive
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
zipfile.structEndArchive64
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
zipfile.structEndArchive64Locator
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
zipfile.structFileHeader
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
zipfile.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
zipfile.threading
Thread module emulating a subset of Java's threading model.

==============================
zipfile.time
This module provides various functions to manipulate time values.

There are two standard representations of time
 One is the number
of seconds since the Epoch, in UTC (a.k.a
GMT)
 It may be an integer
or a floating point number (to represent fractions of seconds).
The Epoch is system-defined; on Unix, it is generally January 1st, 1970.
The actual value can be retrieved by calling gmtime(0).

The other representation is a tuple of 9 integers giving local time.
The tuple items are:
  year (including century, e.g
1998)
  month (1-12)
  day (1-31)
  hours (0-23)
  minutes (0-59)
  seconds (0-59)
  weekday (0-6, Monday is 0)
  Julian day (day in the year, 1-366)
  DST (Daylight Savings Time) flag (-1, 0 or 1)
If the DST flag is 0, the time is given in the regular time zone;
if it is 1, the time is given in the DST time zone;
if it is -1, mktime() should guess based on the date and time.

==============================
zipfile.zlib
The functions in this module allow compression and decompression using the
zlib library, which is based on GNU zip.

adler32(string[, start]) -- Compute an Adler-32 checksum.
compress(data[, level]) -- Compress data, with compression level 0-9 or -1.
compressobj([level[, ...]]) -- Return a compressor object.
crc32(string[, start]) -- Compute a CRC-32 checksum.
decompress(string,[wbits],[bufsize]) -- Decompresses a compressed string.
decompressobj([wbits[, zdict]]]) -- Return a decompressor object.

'wbits' is window buffer size and container format.
Compressor objects support compress() and flush() methods; decompressor
objects support decompress() and flush().

