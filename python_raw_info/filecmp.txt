==============================
filecmp.BUFSIZE
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
filecmp.DEFAULT_IGNORES
Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

==============================
filecmp.clear_cache
()
Clear the filecmp cache.

==============================
filecmp.cmp
(f1, f2, shallow=True)
Compare two files.

Arguments:

f1 -- First file name

f2 -- Second file name

shallow -- Just check stat signature (do not read the files).
           defaults to True.

Return value:

True if the files are the same, False otherwise.

This function uses a cache for past comparisons and the results,
with cache entries invalidated if their stat information
changes
 The cache may be cleared by calling clear_cache().

==============================
filecmp.cmpfiles
(a, b, common, shallow=True)
Compare common files in two directories.

a, b -- directory names
common -- list of file names found in both directories
shallow -- if true, do comparison based solely on stat() information

Returns a tuple of three lists:
  files that compare equal
  files that are different
  filenames that aren't regular files.

==============================
filecmp.demo
()
None

==============================
filecmp.dircmp
(a, b, ignore=None, hide=None)
A class that manages the comparison of 2 directories.

dircmp(a, b, ignore=None, hide=None)
  A and B are directories.
  IGNORE is a list of names to ignore,
    defaults to DEFAULT_IGNORES.
  HIDE is a list of names to hide,
    defaults to [os.curdir, os.pardir].

High level usage:
  x = dircmp(dir1, dir2)
  x.report() -> prints a report on the differences between dir1 and dir2
   or
  x.report_partial_closure() -> prints report on differences between dir1
        and dir2, and reports on common immediate subdirectories.
  x.report_full_closure() -> like report_partial_closure,
        but fully recursive.

Attributes:
 left_list, right_list: The files in dir1 and dir2,
    filtered by hide and ignore.
 common: a list of names in both dir1 and dir2.
 left_only, right_only: names only in dir1, dir2.
 common_dirs: subdirectories in both dir1 and dir2.
 common_files: files in both dir1 and dir2.
 common_funny: names in both dir1 and dir2 where the type differs between
    dir1 and dir2, or the name is not stat-able.
 same_files: list of identical files.
 diff_files: list of filenames which differ.
 funny_files: list of files which could not be compared.
 subdirs: a dictionary of dircmp objects, keyed by names in common_dirs.
 

==============================
filecmp.dircmp.methodmap
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
filecmp.dircmp.phase0
(self)
None

==============================
filecmp.dircmp.phase1
(self)
None

==============================
filecmp.dircmp.phase2
(self)
None

==============================
filecmp.dircmp.phase3
(self)
None

==============================
filecmp.dircmp.phase4
(self)
None

==============================
filecmp.dircmp.phase4_closure
(self)
None

==============================
filecmp.dircmp.report
(self)
None

==============================
filecmp.dircmp.report_full_closure
(self)
None

==============================
filecmp.dircmp.report_partial_closure
(self)
None

==============================
filecmp.filterfalse
(function, iterable, /)
Return those items of iterable for which function(item) is false.

If function is None, return the items that are false.

==============================
filecmp.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
filecmp.stat
Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *

