shutil.chown
(path, user=None, group=None)
Change owner user and group of the given path.
user and group can be the uid/gid or the user/group names, and in that case,
they are converted to their respective uid/gid.
==============================
shutil.copy
(src, dst, *, follow_symlinks=True)
Copy data and mode bits ("cp src dst")
Return the file's destination.
The destination may be a directory.
==============================
shutil.copy2
(src, dst, *, follow_symlinks=True)
Copy data and metadata
Return the file's destination.
Metadata is copied with copystat()
The destination may be a directory.
==============================
shutil.copyfile
(src, dst, *, follow_symlinks=True)
Copy data from src to dst in the most efficient way possible.
==============================
shutil.copyfileobj
(fsrc, fdst, length=0)
copy data from file-like object fsrc to file-like object fdst
==============================
shutil.copymode
(src, dst, *, follow_symlinks=True)
Copy mode bits from src to dst.
Linux) this method does nothing.
==============================
shutil.copystat
(src, dst, *, follow_symlinks=True)
Copy file metadata
Copy the permission bits, last access time, last modification time, and flags from `src` to `dst`
The file contents, owner, and group are unaffected
==============================
shutil.copytree
(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x7f764669b280>, ignore_dangling_symlinks=False, dirs_exist_ok=False)
Recursively copy a directory tree and return the destination directory.
dirs_exist_ok dictates whether to raise an exception in case dst or any missing parent directory already exists.
The optional ignore argument is a callable If given, it is called with the `src` parameter, which is the directory being visited by copytree(), and `names` which is the list of `src` contents, as returned by os.listdir(): callable(src, names) -> ignored_names
The optional copy_function argument is a callable that will be used to copy each file It will be called with the source path and the destination path as arguments
By default, copy2() is used, but any function that supports the same signature (like copy()) can be used.
==============================
shutil.disk_usage
(path)
Return disk usage statistics about the given path.
Returned value is a named tuple with attributes 'total', 'used' and 'free', which are the amount of total, used and free space, in bytes.
==============================
shutil.fnmatch
Filename matching with shell patterns.
fnmatch(FILENAME, PATTERN) matches according to the local convention.
fnmatchcase(FILENAME, PATTERN) always takes case in account.
The functions operate by translating the pattern into a regular
expression
 They cache the compiled regular expressions for speed.
The function translate(PATTERN) returns a regular expression
corresponding to PATTERN
 (It does not compile it.)
==============================
shutil.get_archive_formats
()
Returns a list of supported formats for archiving and unarchiving.
Each element of the returned sequence is a tuple (name, description)
==============================
shutil.get_terminal_size
(fallback=(80, 24))
Get the size of the terminal window.
For each of the two dimensions, the environment variable, COLUMNS
and LINES respectively, is checked
If the variable is defined and
the value is a positive integer, it is used.
When COLUMNS or LINES is not defined, which is the common case,
the terminal connected to sys.__stdout__ is queried
by invoking os.get_terminal_size.
If the terminal size cannot be successfully queried, either because
the system doesn't support querying, or because we are not
connected to a terminal, the value given in fallback parameter
is used
Fallback defaults to (80, 24) which is the default
size used by many terminal emulators.
The value returned is a named tuple of type os.terminal_size.
==============================
shutil.get_unpack_formats
()
Returns a list of supported formats for unpacking.
Each element of the returned sequence is a tuple
(name, extensions, description)
==============================
shutil.getgrnam
(name)
Return the group database entry for the given group name.
If name is not valid, raise KeyError.
==============================
shutil.getpwnam
(name, /)
Return the password database entry for the given user name.
See `help(pwd)` for more on password database entries.
==============================
shutil.ignore_patterns
(*patterns)
Function that can be used as copytree() ignore parameter.
Patterns is a sequence of glob-style patterns
that are used to exclude files
==============================
shutil.make_archive
(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)
Create an archive file (eg
zip or tar).
'base_name' is the name of the file to create, minus any format-specific
extension; 'format' is the archive format: one of "zip", "tar", "gztar",
"bztar", or "xztar"
 Or any other registered format.
'root_dir' is a directory that will be the root directory of the
archive; ie
we typically chdir into 'root_dir' before creating the
archive
 'base_dir' is the directory where we start archiving from;
ie
'base_dir' will be the common prefix of all files and
directories in the archive
 'root_dir' and 'base_dir' both default
to the current directory
 Returns the name of the archive file.
'owner' and 'group' are used when creating a tar archive
By default,
uses the current owner and group.
==============================
shutil.move
(src, dst, copy_function=<function copy2 at 0x7f764669b280>)
Recursively move a file or directory to another location
This is
similar to the Unix "mv" command
Return the file or directory's
destination.
If the destination is a directory or a symlink to a directory, the source
is moved inside the directory
The destination path must not already
exist.
If the destination already exists but is not a directory, it may be
overwritten depending on os.rename() semantics.
If the destination is on our current filesystem, then rename() is used.
Otherwise, src is copied to the destination and then removed
Symlinks are
recreated under the new name if os.rename() fails because of cross
filesystem renames.
The optional `copy_function` argument is a callable that will be used
to copy the source or it will be delegated to `copytree`.
By default, copy2() is used, but any function that supports the same
signature (like copy()) can be used.
A lot more could be done here..
 A look at a mv.c shows a lot of
the issues this implementation glosses over.
==============================
shutil.nt
None
==============================
shutil.os
OS routines for NT or Posix depending on what system we're on.
This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)
Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).
==============================
shutil.posix
This module provides access to operating system functionality that is
standardized by the C Standard and the POSIX standard (a thinly
disguised Unix interface)
 Refer to the library manual and
corresponding Unix manual entries for more information on calls.
==============================
shutil.register_archive_format
(name, function, extra_args=None, description='')
Registers an archive format.
name is the name of the format
function is the callable that will be
used to create archives
If provided, extra_args is a sequence of
(name, value) tuples that will be passed as arguments to the callable.
description can be provided to describe the format, and will be returned
by the get_archive_formats() function.
==============================
shutil.register_unpack_format
(name, extensions, function, extra_args=None, description='')
Registers an unpack format.
`name` is the name of the format
`extensions` is a list of extensions
corresponding to the format.
`function` is the callable that will be
used to unpack archives
The callable will receive archives to unpack.
If it's unable to handle an archive, it needs to raise a ReadError
exception.
If provided, `extra_args` is a sequence of
(name, value) tuples that will be passed as arguments to the callable.
description can be provided to describe the format, and will be returned
by the get_unpack_formats() function.
==============================
shutil.rmtree
(path, ignore_errors=False, onerror=None)
Recursively delete a directory tree.
If ignore_errors is set, errors are ignored; otherwise, if onerror
is set, it is called to handle the error with arguments (func,
path, exc_info) where func is platform and implementation dependent;
path is the argument to that function that caused it to fail; and
exc_info is a tuple returned by sys.exc_info()
 If ignore_errors
is false and onerror is None, an exception is raised.
==============================
shutil.stat
Constants/functions for interpreting results of os.stat() and os.lstat().
Suggested usage: from stat import *
==============================
shutil.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.
Dynamic objects:
argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules
displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.
stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.
last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.
Static objects:
builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!
Functions:
displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function
==============================
shutil.unpack_archive
(filename, extract_dir=None, format=None)
Unpack an archive.
`filename` is the name of the archive.
`extract_dir` is the name of the target directory, where the archive
is unpacked
If not provided, the current working directory is used.
`format` is the archive format: one of "zip", "tar", "gztar", "bztar",
or "xztar"
 Or any other registered format
 If not provided,
unpack_archive will use the filename extension and see if an unpacker
was registered for that extension.
In case none is found, a ValueError is raised.
==============================
shutil.unregister_archive_format
(name)
None
==============================
shutil.unregister_unpack_format
(name)
Removes the pack format from the registry.
==============================
shutil.which
(cmd, mode=1, path=None)
Given a command, mode, and a PATH string, return the path which
conforms to the given mode on the PATH, or None if there is no such
file.
`mode` defaults to os.F_OK | os.X_OK
`path` defaults to the result
of os.environ.get("PATH"), or can be overridden with a custom search
path.
