==============================
shutil.COPY_BUFSIZE
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
shutil.Error
Base class for I/O related errors.

==============================
shutil.Error.args
None

==============================
shutil.Error.characters_written
None

==============================
shutil.Error.errno
POSIX exception code

==============================
shutil.Error.filename
exception filename

==============================
shutil.Error.filename2
second exception filename

==============================
shutil.Error.strerror
exception strerror

==============================
shutil.Error.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
shutil.ExecError
Raised when a command could not be executed

==============================
shutil.ExecError.args
None

==============================
shutil.ExecError.characters_written
None

==============================
shutil.ExecError.errno
POSIX exception code

==============================
shutil.ExecError.filename
exception filename

==============================
shutil.ExecError.filename2
second exception filename

==============================
shutil.ExecError.strerror
exception strerror

==============================
shutil.ExecError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
shutil.ReadError
Raised when an archive cannot be read

==============================
shutil.ReadError.args
None

==============================
shutil.ReadError.characters_written
None

==============================
shutil.ReadError.errno
POSIX exception code

==============================
shutil.ReadError.filename
exception filename

==============================
shutil.ReadError.filename2
second exception filename

==============================
shutil.ReadError.strerror
exception strerror

==============================
shutil.ReadError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
shutil.RegistryError
Raised when a registry operation with the archiving
and unpacking registries fails

==============================
shutil.RegistryError.args
None

==============================
shutil.RegistryError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
shutil.SameFileError
Raised when source and destination are the same file.

==============================
shutil.SameFileError.args
None

==============================
shutil.SameFileError.characters_written
None

==============================
shutil.SameFileError.errno
POSIX exception code

==============================
shutil.SameFileError.filename
exception filename

==============================
shutil.SameFileError.filename2
second exception filename

==============================
shutil.SameFileError.strerror
exception strerror

==============================
shutil.SameFileError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
shutil.SpecialFileError
Raised when trying to do a kind of operation (e.g
copying) which is
not supported on a special file (e.g
a named pipe)

==============================
shutil.SpecialFileError.args
None

==============================
shutil.SpecialFileError.characters_written
None

==============================
shutil.SpecialFileError.errno
POSIX exception code

==============================
shutil.SpecialFileError.filename
exception filename

==============================
shutil.SpecialFileError.filename2
second exception filename

==============================
shutil.SpecialFileError.strerror
exception strerror

==============================
shutil.SpecialFileError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
shutil.chown
(path, user=None, group=None)
Change owner user and group of the given path.

user and group can be the uid/gid or the user/group names, and in that case,
they are converted to their respective uid/gid.

==============================
shutil.collections
This module implements specialized container datatypes providing
alternatives to Python's general purpose built-in containers, dict,
list, set, and tuple.

* namedtuple   factory function for creating tuple subclasses with named fields
* deque        list-like container with fast appends and pops on either end
* ChainMap     dict-like class for creating a single view of multiple mappings
* Counter      dict subclass for counting hashable objects
* OrderedDict  dict subclass that remembers the order entries were added
* defaultdict  dict subclass that calls a factory function to supply missing values
* UserDict     wrapper around dictionary objects for easier dict subclassing
* UserList     wrapper around list objects for easier list subclassing
* UserString   wrapper around string objects for easier string subclassing

==============================
shutil.copy
(src, dst, *, follow_symlinks=True)
Copy data and mode bits ("cp src dst")
Return the file's destination.

The destination may be a directory.

If follow_symlinks is false, symlinks won't be followed
This
resembles GNU's "cp -P src dst".

If source and destination are the same file, a SameFileError will be
raised.

==============================
shutil.copy2
(src, dst, *, follow_symlinks=True)
Copy data and metadata
Return the file's destination.

Metadata is copied with copystat()
Please see the copystat function
for more information.

The destination may be a directory.

If follow_symlinks is false, symlinks won't be followed
This
resembles GNU's "cp -P src dst".

==============================
shutil.copyfile
(src, dst, *, follow_symlinks=True)
Copy data from src to dst in the most efficient way possible.

If follow_symlinks is not set and src is a symbolic link, a new
symlink will be created instead of copying the file it points to.

==============================
shutil.copyfileobj
(fsrc, fdst, length=0)
copy data from file-like object fsrc to file-like object fdst

==============================
shutil.copymode
(src, dst, *, follow_symlinks=True)
Copy mode bits from src to dst.

If follow_symlinks is not set, symlinks aren't followed if and only
if both `src` and `dst` are symlinks
 If `lchmod` isn't available
(e.g
Linux) this method does nothing.

==============================
shutil.copystat
(src, dst, *, follow_symlinks=True)
Copy file metadata

Copy the permission bits, last access time, last modification time, and
flags from `src` to `dst`
On Linux, copystat() also copies the "extended
attributes" where possible
The file contents, owner, and group are
unaffected
`src` and `dst` are path-like objects or path names given as
strings.

If the optional flag `follow_symlinks` is not set, symlinks aren't
followed if and only if both `src` and `dst` are symlinks.

==============================
shutil.copytree
(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x7f764669b280>, ignore_dangling_symlinks=False, dirs_exist_ok=False)
Recursively copy a directory tree and return the destination directory.

dirs_exist_ok dictates whether to raise an exception in case dst or any
missing parent directory already exists.

If exception(s) occur, an Error is raised with a list of reasons.

If the optional symlinks flag is true, symbolic links in the
source tree result in symbolic links in the destination tree; if
it is false, the contents of the files pointed to by symbolic
links are copied
If the file pointed by the symlink doesn't
exist, an exception will be added in the list of errors raised in
an Error exception at the end of the copy process.

You can set the optional ignore_dangling_symlinks flag to true if you
want to silence this exception
Notice that this has no effect on
platforms that don't support os.symlink.

The optional ignore argument is a callable
If given, it
is called with the `src` parameter, which is the directory
being visited by copytree(), and `names` which is the list of
`src` contents, as returned by os.listdir():

    callable(src, names) -> ignored_names

Since copytree() is called recursively, the callable will be
called once for each directory that is copied
It returns a
list of names relative to the `src` directory that should
not be copied.

The optional copy_function argument is a callable that will be used
to copy each file
It will be called with the source path and the
destination path as arguments
By default, copy2() is used, but any
function that supports the same signature (like copy()) can be used.

==============================
shutil.disk_usage
(path)
Return disk usage statistics about the given path.

Returned value is a named tuple with attributes 'total', 'used' and
'free', which are the amount of total, used and free space, in bytes.

==============================
shutil.errno
This module makes available standard errno system symbols.

The value of each symbol is the corresponding integer value,
e.g., on most systems, errno.ENOENT equals the integer 2.

The dictionary errno.errorcode maps numeric codes to symbol names,
e.g., errno.errorcode[2] could be the string 'ENOENT'.

Symbols that are not relevant to the underlying system are not defined.

To map error codes to error messages, use the function os.strerror(),
e.g
os.strerror(2) could return 'No such file or directory'.

==============================
shutil.fnmatch
Filename matching with shell patterns.

fnmatch(FILENAME, PATTERN) matches according to the local convention.
fnmatchcase(FILENAME, PATTERN) always takes case in account.

The functions operate by translating the pattern into a regular
expression
 They cache the compiled regular expressions for speed.

The function translate(PATTERN) returns a regular expression
corresponding to PATTERN
 (It does not compile it.)

==============================
shutil.get_archive_formats
()
Returns a list of supported formats for archiving and unarchiving.

Each element of the returned sequence is a tuple (name, description)

==============================
shutil.get_terminal_size
(fallback=(80, 24))
Get the size of the terminal window.

For each of the two dimensions, the environment variable, COLUMNS
and LINES respectively, is checked
If the variable is defined and
the value is a positive integer, it is used.

When COLUMNS or LINES is not defined, which is the common case,
the terminal connected to sys.__stdout__ is queried
by invoking os.get_terminal_size.

If the terminal size cannot be successfully queried, either because
the system doesn't support querying, or because we are not
connected to a terminal, the value given in fallback parameter
is used
Fallback defaults to (80, 24) which is the default
size used by many terminal emulators.

The value returned is a named tuple of type os.terminal_size.

==============================
shutil.get_unpack_formats
()
Returns a list of supported formats for unpacking.

Each element of the returned sequence is a tuple
(name, extensions, description)

==============================
shutil.getgrnam
(name)
Return the group database entry for the given group name.

If name is not valid, raise KeyError.

==============================
shutil.getpwnam
(name, /)
Return the password database entry for the given user name.

See `help(pwd)` for more on password database entries.

==============================
shutil.ignore_patterns
(*patterns)
Function that can be used as copytree() ignore parameter.

Patterns is a sequence of glob-style patterns
that are used to exclude files

==============================
shutil.make_archive
(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)
Create an archive file (eg
zip or tar).

'base_name' is the name of the file to create, minus any format-specific
extension; 'format' is the archive format: one of "zip", "tar", "gztar",
"bztar", or "xztar"
 Or any other registered format.

'root_dir' is a directory that will be the root directory of the
archive; ie
we typically chdir into 'root_dir' before creating the
archive
 'base_dir' is the directory where we start archiving from;
ie
'base_dir' will be the common prefix of all files and
directories in the archive
 'root_dir' and 'base_dir' both default
to the current directory
 Returns the name of the archive file.

'owner' and 'group' are used when creating a tar archive
By default,
uses the current owner and group.

==============================
shutil.move
(src, dst, copy_function=<function copy2 at 0x7f764669b280>)
Recursively move a file or directory to another location
This is
similar to the Unix "mv" command
Return the file or directory's
destination.

If the destination is a directory or a symlink to a directory, the source
is moved inside the directory
The destination path must not already
exist.

If the destination already exists but is not a directory, it may be
overwritten depending on os.rename() semantics.

If the destination is on our current filesystem, then rename() is used.
Otherwise, src is copied to the destination and then removed
Symlinks are
recreated under the new name if os.rename() fails because of cross
filesystem renames.

The optional `copy_function` argument is a callable that will be used
to copy the source or it will be delegated to `copytree`.
By default, copy2() is used, but any function that supports the same
signature (like copy()) can be used.

A lot more could be done here..
 A look at a mv.c shows a lot of
the issues this implementation glosses over.

==============================
shutil.nt
None

==============================
shutil.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
shutil.posix
This module provides access to operating system functionality that is
standardized by the C Standard and the POSIX standard (a thinly
disguised Unix interface)
 Refer to the library manual and
corresponding Unix manual entries for more information on calls.

==============================
shutil.register_archive_format
(name, function, extra_args=None, description='')
Registers an archive format.

name is the name of the format
function is the callable that will be
used to create archives
If provided, extra_args is a sequence of
(name, value) tuples that will be passed as arguments to the callable.
description can be provided to describe the format, and will be returned
by the get_archive_formats() function.

==============================
shutil.register_unpack_format
(name, extensions, function, extra_args=None, description='')
Registers an unpack format.

`name` is the name of the format
`extensions` is a list of extensions
corresponding to the format.

`function` is the callable that will be
used to unpack archives
The callable will receive archives to unpack.
If it's unable to handle an archive, it needs to raise a ReadError
exception.

If provided, `extra_args` is a sequence of
(name, value) tuples that will be passed as arguments to the callable.
description can be provided to describe the format, and will be returned
by the get_unpack_formats() function.

==============================
shutil.rmtree
(path, ignore_errors=False, onerror=None)
Recursively delete a directory tree.

If ignore_errors is set, errors are ignored; otherwise, if onerror
is set, it is called to handle the error with arguments (func,
path, exc_info) where func is platform and implementation dependent;
path is the argument to that function that caused it to fail; and
exc_info is a tuple returned by sys.exc_info()
 If ignore_errors
is false and onerror is None, an exception is raised.

==============================
shutil.stat
Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *

==============================
shutil.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
shutil.unpack_archive
(filename, extract_dir=None, format=None)
Unpack an archive.

`filename` is the name of the archive.

`extract_dir` is the name of the target directory, where the archive
is unpacked
If not provided, the current working directory is used.

`format` is the archive format: one of "zip", "tar", "gztar", "bztar",
or "xztar"
 Or any other registered format
 If not provided,
unpack_archive will use the filename extension and see if an unpacker
was registered for that extension.

In case none is found, a ValueError is raised.

==============================
shutil.unregister_archive_format
(name)
None

==============================
shutil.unregister_unpack_format
(name)
Removes the pack format from the registry.

==============================
shutil.which
(cmd, mode=1, path=None)
Given a command, mode, and a PATH string, return the path which
conforms to the given mode on the PATH, or None if there is no such
file.

`mode` defaults to os.F_OK | os.X_OK
`path` defaults to the result
of os.environ.get("PATH"), or can be overridden with a custom search
path.

