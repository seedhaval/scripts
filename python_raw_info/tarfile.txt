==============================
tarfile.AREGTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.BLKTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.BLOCKSIZE
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.CHRTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.CONTTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.CompressionError
Exception for unavailable compression methods.

==============================
tarfile.CompressionError.args
None

==============================
tarfile.CompressionError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.DEFAULT_FORMAT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.DIRTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.ENCODING
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
tarfile.EOFHeaderError
Exception for end of file headers.

==============================
tarfile.EOFHeaderError.args
None

==============================
tarfile.EOFHeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.EmptyHeaderError
Exception for empty headers.

==============================
tarfile.EmptyHeaderError.args
None

==============================
tarfile.EmptyHeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.ExFileObject
(tarfile, tarinfo)
Create a new buffered reader using the given readable raw IO object.

==============================
tarfile.ExFileObject.close
Flush and close the IO object.

This method has no effect if the file is already closed.

==============================
tarfile.ExFileObject.closed
None

==============================
tarfile.ExFileObject.detach
Disconnect this buffer from its underlying raw stream and return it.

After the raw stream has been detached, the buffer is in an unusable
state.

==============================
tarfile.ExFileObject.fileno
Returns underlying file descriptor if one exists.

OSError is raised if the IO object does not use a file descriptor.

==============================
tarfile.ExFileObject.flush
Flush write buffers, if applicable.

This is not implemented for read-only and non-blocking streams.

==============================
tarfile.ExFileObject.isatty
Return whether this is an 'interactive' stream.

Return False if it can't be determined.

==============================
tarfile.ExFileObject.mode
None

==============================
tarfile.ExFileObject.name
None

==============================
tarfile.ExFileObject.peek
(self, size=0, /)
None

==============================
tarfile.ExFileObject.raw
None

==============================
tarfile.ExFileObject.read
(self, size=-1, /)
Read and return up to n bytes.

If the argument is omitted, None, or negative, reads and
returns all data until EOF.

If the argument is positive, and the underlying raw stream is
not 'interactive', multiple raw reads may be issued to satisfy
the byte count (unless EOF is reached first)
 But for
interactive raw streams (as well as sockets and pipes), at most
one raw read will be issued, and a short result does not imply
that EOF is imminent.

Returns an empty bytes object on EOF.

Returns None if the underlying raw stream was open in non-blocking
mode and no data is available at the moment.

==============================
tarfile.ExFileObject.read1
(self, size=-1, /)
Read and return up to n bytes, with at most one read() call
to the underlying raw stream
A short result does not imply
that EOF is imminent.

Returns an empty bytes object on EOF.

==============================
tarfile.ExFileObject.readable
Return whether object was opened for reading.

If False, read() will raise OSError.

==============================
tarfile.ExFileObject.readinto
(self, buffer, /)
None

==============================
tarfile.ExFileObject.readinto1
(self, buffer, /)
None

==============================
tarfile.ExFileObject.readline
(self, size=-1, /)
Read and return a line from the stream.

If size is specified, at most size bytes will be read.

The line terminator is always b'\n' for binary files; for text
files, the newlines argument to open can be used to select the line
terminator(s) recognized.

==============================
tarfile.ExFileObject.readlines
(self, hint=-1, /)
Return a list of lines from the stream.

hint can be specified to control the number of lines read: no more
lines will be read if the total size (in bytes/characters) of all
lines so far exceeds hint.

==============================
tarfile.ExFileObject.seek
(self, target, whence=0, /)
Change stream position.

Change the stream position to the given byte offset
The offset is
interpreted relative to the position indicated by whence
 Values
for whence are:

* 0 -- start of stream (the default); offset should be zero or positive
* 1 -- current stream position; offset may be negative
* 2 -- end of stream; offset is usually negative

Return the new absolute position.

==============================
tarfile.ExFileObject.seekable
Return whether object supports random access.

If False, seek(), tell() and truncate() will raise OSError.
This method may need to do a test seek().

==============================
tarfile.ExFileObject.tell
Return current stream position.

==============================
tarfile.ExFileObject.truncate
(self, pos=None, /)
Truncate file to size bytes.

File pointer is left unchanged
 Size defaults to the current IO
position as reported by tell()
 Returns the new size.

==============================
tarfile.ExFileObject.writable
(self, /)
Return whether object was opened for writing.

If False, write() will raise OSError.

==============================
tarfile.ExFileObject.write
Write the given buffer to the IO stream.

Returns the number of bytes written, which is always the length of b
in bytes.

Raises BlockingIOError if the buffer is full and the
underlying raw stream cannot accept more data at the moment.

==============================
tarfile.ExFileObject.writelines
(self, lines, /)
Write a list of lines to stream.

Line separators are not added, so it is usual for each of the
lines provided to have a line separator at the end.

==============================
tarfile.ExtractError
General exception for extract errors.

==============================
tarfile.ExtractError.args
None

==============================
tarfile.ExtractError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.FIFOTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.GNUTYPE_LONGLINK
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.GNUTYPE_LONGNAME
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.GNUTYPE_SPARSE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.GNU_FORMAT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.GNU_MAGIC
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.GNU_TYPES
Built-in immutable sequence.

If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.

If the argument is a tuple, the return value is the same object.

==============================
tarfile.HeaderError
Base exception for header errors.

==============================
tarfile.HeaderError.args
None

==============================
tarfile.HeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.InvalidHeaderError
Exception for invalid headers.

==============================
tarfile.InvalidHeaderError.args
None

==============================
tarfile.InvalidHeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.LENGTH_LINK
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.LENGTH_NAME
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.LENGTH_PREFIX
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.LNKTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.NUL
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.PAX_FIELDS
Built-in immutable sequence.

If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.

If the argument is a tuple, the return value is the same object.

==============================
tarfile.PAX_FORMAT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.PAX_NAME_FIELDS
set() -> new empty set object
set(iterable) -> new set object

Build an unordered collection of unique elements.

==============================
tarfile.PAX_NUMBER_FIELDS
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
tarfile.POSIX_MAGIC
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.RECORDSIZE
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.REGTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.REGULAR_TYPES
Built-in immutable sequence.

If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.

If the argument is a tuple, the return value is the same object.

==============================
tarfile.ReadError
Exception for unreadable tar archives.

==============================
tarfile.ReadError.args
None

==============================
tarfile.ReadError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.SOLARIS_XHDTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.SUPPORTED_TYPES
Built-in immutable sequence.

If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.

If the argument is a tuple, the return value is the same object.

==============================
tarfile.SYMTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.StreamError
Exception for unsupported operations on stream-like TarFiles.

==============================
tarfile.StreamError.args
None

==============================
tarfile.StreamError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.SubsequentHeaderError
Exception for missing and invalid extended headers.

==============================
tarfile.SubsequentHeaderError.args
None

==============================
tarfile.SubsequentHeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.TarError
Base exception.

==============================
tarfile.TarError.args
None

==============================
tarfile.TarError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.TarFile
(name=None, mode='r', fileobj=None, format=None, tarinfo=None, dereference=None, ignore_zeros=None, encoding=None, errors='surrogateescape', pax_headers=None, debug=None, errorlevel=None, copybufsize=None)
The TarFile Class provides an interface to tar archives.
    

==============================
tarfile.TarFile.OPEN_METH
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
tarfile.TarFile.add
(self, name, arcname=None, recursive=True, *, filter=None)
Add the file `name' to the archive
`name' may be any type of file
(directory, fifo, symbolic link, etc.)
If given, `arcname'
specifies an alternative name for the file in the archive.
Directories are added recursively by default
This can be avoided by
setting `recursive' to False
`filter' is a function
that expects a TarInfo object argument and returns the changed
TarInfo object, if it returns None the TarInfo object will be
excluded from the archive.

==============================
tarfile.TarFile.addfile
(self, tarinfo, fileobj=None)
Add the TarInfo object `tarinfo' to the archive
If `fileobj' is
given, it should be a binary file, and tarinfo.size bytes are read
from it and added to the archive
You can create TarInfo objects
directly, or by using gettarinfo().

==============================
tarfile.TarFile.bz2open
(name, mode='r', fileobj=None, compresslevel=9, **kwargs)
Open bzip2 compressed tar archive name for reading or writing.
Appending is not allowed.

==============================
tarfile.TarFile.chmod
(self, tarinfo, targetpath)
Set file permissions of targetpath according to tarinfo.
        

==============================
tarfile.TarFile.chown
(self, tarinfo, targetpath, numeric_owner)
Set owner of targetpath according to tarinfo
If numeric_owner
is True, use .gid/.uid instead of .gname/.uname
If numeric_owner
is False, fall back to .gid/.uid when the search based on name
fails.

==============================
tarfile.TarFile.close
(self)
Close the TarFile
In write-mode, two finishing zero blocks are
appended to the archive.

==============================
tarfile.TarFile.debug
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.TarFile.dereference
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

==============================
tarfile.TarFile.encoding
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
tarfile.TarFile.errorlevel
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.TarFile.errors
None

==============================
tarfile.TarFile.extract
(self, member, path='', set_attrs=True, *, numeric_owner=False)
Extract a member from the archive to the current working directory,
using its full name
Its file information is extracted as accurately
as possible
`member' may be a filename or a TarInfo object
You can
specify a different directory using `path'
File attributes (owner,
mtime, mode) are set unless `set_attrs' is False
If `numeric_owner`
is True, only the numbers for user/group names are used and not
the names.

==============================
tarfile.TarFile.extractall
(self, path='.', members=None, *, numeric_owner=False)
Extract all members from the archive to the current working
directory and set owner, modification time and permissions on
directories afterwards
`path' specifies a different directory
to extract to
`members' is optional and must be a subset of the
list returned by getmembers()
If `numeric_owner` is True, only
the numbers for user/group names are used and not the names.

==============================
tarfile.TarFile.extractfile
(self, member)
Extract a member from the archive as a file object
`member' may be
a filename or a TarInfo object
If `member' is a regular file or a
link, an io.BufferedReader object is returned
Otherwise, None is
returned.

==============================
tarfile.TarFile.fileobject
(tarfile, tarinfo)
Create a new buffered reader using the given readable raw IO object.

==============================
tarfile.TarFile.fileobject.close
Flush and close the IO object.

This method has no effect if the file is already closed.

==============================
tarfile.TarFile.fileobject.closed
None

==============================
tarfile.TarFile.fileobject.detach
Disconnect this buffer from its underlying raw stream and return it.

After the raw stream has been detached, the buffer is in an unusable
state.

==============================
tarfile.TarFile.fileobject.fileno
Returns underlying file descriptor if one exists.

OSError is raised if the IO object does not use a file descriptor.

==============================
tarfile.TarFile.fileobject.flush
Flush write buffers, if applicable.

This is not implemented for read-only and non-blocking streams.

==============================
tarfile.TarFile.fileobject.isatty
Return whether this is an 'interactive' stream.

Return False if it can't be determined.

==============================
tarfile.TarFile.fileobject.mode
None

==============================
tarfile.TarFile.fileobject.name
None

==============================
tarfile.TarFile.fileobject.peek
(self, size=0, /)
None

==============================
tarfile.TarFile.fileobject.raw
None

==============================
tarfile.TarFile.fileobject.read
(self, size=-1, /)
Read and return up to n bytes.

If the argument is omitted, None, or negative, reads and
returns all data until EOF.

If the argument is positive, and the underlying raw stream is
not 'interactive', multiple raw reads may be issued to satisfy
the byte count (unless EOF is reached first)
 But for
interactive raw streams (as well as sockets and pipes), at most
one raw read will be issued, and a short result does not imply
that EOF is imminent.

Returns an empty bytes object on EOF.

Returns None if the underlying raw stream was open in non-blocking
mode and no data is available at the moment.

==============================
tarfile.TarFile.fileobject.read1
(self, size=-1, /)
Read and return up to n bytes, with at most one read() call
to the underlying raw stream
A short result does not imply
that EOF is imminent.

Returns an empty bytes object on EOF.

==============================
tarfile.TarFile.fileobject.readable
Return whether object was opened for reading.

If False, read() will raise OSError.

==============================
tarfile.TarFile.fileobject.readinto
(self, buffer, /)
None

==============================
tarfile.TarFile.fileobject.readinto1
(self, buffer, /)
None

==============================
tarfile.TarFile.fileobject.readline
(self, size=-1, /)
Read and return a line from the stream.

If size is specified, at most size bytes will be read.

The line terminator is always b'\n' for binary files; for text
files, the newlines argument to open can be used to select the line
terminator(s) recognized.

==============================
tarfile.TarFile.fileobject.readlines
(self, hint=-1, /)
Return a list of lines from the stream.

hint can be specified to control the number of lines read: no more
lines will be read if the total size (in bytes/characters) of all
lines so far exceeds hint.

==============================
tarfile.TarFile.fileobject.seek
(self, target, whence=0, /)
Change stream position.

Change the stream position to the given byte offset
The offset is
interpreted relative to the position indicated by whence
 Values
for whence are:

* 0 -- start of stream (the default); offset should be zero or positive
* 1 -- current stream position; offset may be negative
* 2 -- end of stream; offset is usually negative

Return the new absolute position.

==============================
tarfile.TarFile.fileobject.seekable
Return whether object supports random access.

If False, seek(), tell() and truncate() will raise OSError.
This method may need to do a test seek().

==============================
tarfile.TarFile.fileobject.tell
Return current stream position.

==============================
tarfile.TarFile.fileobject.truncate
(self, pos=None, /)
Truncate file to size bytes.

File pointer is left unchanged
 Size defaults to the current IO
position as reported by tell()
 Returns the new size.

==============================
tarfile.TarFile.fileobject.writable
(self, /)
Return whether object was opened for writing.

If False, write() will raise OSError.

==============================
tarfile.TarFile.fileobject.write
Write the given buffer to the IO stream.

Returns the number of bytes written, which is always the length of b
in bytes.

Raises BlockingIOError if the buffer is full and the
underlying raw stream cannot accept more data at the moment.

==============================
tarfile.TarFile.fileobject.writelines
(self, lines, /)
Write a list of lines to stream.

Line separators are not added, so it is usual for each of the
lines provided to have a line separator at the end.

==============================
tarfile.TarFile.format
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.TarFile.getmember
(self, name)
Return a TarInfo object for member `name'
If `name' can not be
found in the archive, KeyError is raised
If a member occurs more
than once in the archive, its last occurrence is assumed to be the
most up-to-date version.

==============================
tarfile.TarFile.getmembers
(self)
Return the members of the archive as a list of TarInfo objects
The
list has the same order as the members in the archive.

==============================
tarfile.TarFile.getnames
(self)
Return the members of the archive as a list of their names
It has
the same order as the list returned by getmembers().

==============================
tarfile.TarFile.gettarinfo
(self, name=None, arcname=None, fileobj=None)
Create a TarInfo object from the result of os.stat or equivalent
on an existing file
The file is either named by `name', or
specified as a file object `fileobj' with a file descriptor
If
given, `arcname' specifies an alternative name for the file in the
archive, otherwise, the name is taken from the 'name' attribute of
'fileobj', or the 'name' argument
The name should be a text
string.

==============================
tarfile.TarFile.gzopen
(name, mode='r', fileobj=None, compresslevel=9, **kwargs)
Open gzip compressed tar archive name for reading or writing.
Appending is not allowed.

==============================
tarfile.TarFile.ignore_zeros
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

==============================
tarfile.TarFile.list
(self, verbose=True, *, members=None)
Print a table of contents to sys.stdout
If `verbose' is False, only
the names of the members are printed
If it is True, an `ls -l'-like
output is produced
`members' is optional and must be a subset of the
list returned by getmembers().

==============================
tarfile.TarFile.makedev
(self, tarinfo, targetpath)
Make a character or block device called targetpath.
        

==============================
tarfile.TarFile.makedir
(self, tarinfo, targetpath)
Make a directory called targetpath.
        

==============================
tarfile.TarFile.makefifo
(self, tarinfo, targetpath)
Make a fifo called targetpath.
        

==============================
tarfile.TarFile.makefile
(self, tarinfo, targetpath)
Make a file called targetpath.
        

==============================
tarfile.TarFile.makelink
(self, tarinfo, targetpath)
Make a (symbolic) link called targetpath
If it cannot be created
(platform limitation), we try to make a copy of the referenced file
instead of a link.

==============================
tarfile.TarFile.makeunknown
(self, tarinfo, targetpath)
Make a file from a TarInfo object with an unknown type
at targetpath.

==============================
tarfile.TarFile.next
(self)
Return the next member of the archive as a TarInfo object, when
TarFile is opened for reading
Return None if there is no more
available.

==============================
tarfile.TarFile.open
(name=None, mode='r', fileobj=None, bufsize=10240, **kwargs)
Open a tar archive for reading, writing or appending
Return
an appropriate TarFile class.

mode:
'r' or 'r:*' open for reading with transparent compression
'r:'         open for reading exclusively uncompressed
'r:gz'       open for reading with gzip compression
'r:bz2'      open for reading with bzip2 compression
'r:xz'       open for reading with lzma compression
'a' or 'a:'  open for appending, creating the file if necessary
'w' or 'w:'  open for writing without compression
'w:gz'       open for writing with gzip compression
'w:bz2'      open for writing with bzip2 compression
'w:xz'       open for writing with lzma compression

'x' or 'x:'  create a tarfile exclusively without compression, raise
             an exception if the file is already created
'x:gz'       create a gzip compressed tarfile, raise an exception
             if the file is already created
'x:bz2'      create a bzip2 compressed tarfile, raise an exception
             if the file is already created
'x:xz'       create an lzma compressed tarfile, raise an exception
             if the file is already created

'r|*'        open a stream of tar blocks with transparent compression
'r|'         open an uncompressed stream of tar blocks for reading
'r|gz'       open a gzip compressed stream of tar blocks
'r|bz2'      open a bzip2 compressed stream of tar blocks
'r|xz'       open an lzma compressed stream of tar blocks
'w|'         open an uncompressed stream for writing
'w|gz'       open a gzip compressed stream for writing
'w|bz2'      open a bzip2 compressed stream for writing
'w|xz'       open an lzma compressed stream for writing

==============================
tarfile.TarFile.tarinfo
(name='')
Informational class which holds the details about an
archive member given by a tar header block.
TarInfo objects are returned by TarFile.getmember(),
TarFile.getmembers() and TarFile.gettarinfo() and are
usually created internally.

==============================
tarfile.TarFile.tarinfo.chksum
Header checksum.

==============================
tarfile.TarFile.tarinfo.create_gnu_header
(self, info, encoding, errors)
Return the object as a GNU header block sequence.
        

==============================
tarfile.TarFile.tarinfo.create_pax_global_header
(pax_headers)
Return the object as a pax global header block sequence.
        

==============================
tarfile.TarFile.tarinfo.create_pax_header
(self, info, encoding)
Return the object as a ustar header block
If it cannot be
represented this way, prepend a pax extended header sequence
with supplement information.

==============================
tarfile.TarFile.tarinfo.create_ustar_header
(self, info, encoding, errors)
Return the object as a ustar header block.
        

==============================
tarfile.TarFile.tarinfo.devmajor
Device major number.

==============================
tarfile.TarFile.tarinfo.devminor
Device minor number.

==============================
tarfile.TarFile.tarinfo.frombuf
(buf, encoding, errors)
Construct a TarInfo object from a 512 byte bytes object.
        

==============================
tarfile.TarFile.tarinfo.fromtarfile
(tarfile)
Return the next TarInfo object from TarFile object
tarfile.

==============================
tarfile.TarFile.tarinfo.get_info
(self)
Return the TarInfo's attributes as a dictionary.
        

==============================
tarfile.TarFile.tarinfo.gid
Group ID of the user who originally stored this member.

==============================
tarfile.TarFile.tarinfo.gname
Group name.

==============================
tarfile.TarFile.tarinfo.isblk
(self)
Return True if it is a block device.

==============================
tarfile.TarFile.tarinfo.ischr
(self)
Return True if it is a character device.

==============================
tarfile.TarFile.tarinfo.isdev
(self)
Return True if it is one of character device, block device or FIFO.

==============================
tarfile.TarFile.tarinfo.isdir
(self)
Return True if it is a directory.

==============================
tarfile.TarFile.tarinfo.isfifo
(self)
Return True if it is a FIFO.

==============================
tarfile.TarFile.tarinfo.isfile
(self)
Return True if the Tarinfo object is a regular file.

==============================
tarfile.TarFile.tarinfo.islnk
(self)
Return True if it is a hard link.

==============================
tarfile.TarFile.tarinfo.isreg
(self)
Return True if the Tarinfo object is a regular file.

==============================
tarfile.TarFile.tarinfo.issparse
(self)
None

==============================
tarfile.TarFile.tarinfo.issym
(self)
Return True if it is a symbolic link.

==============================
tarfile.TarFile.tarinfo.linkname
Name of the target file name, which is only present in TarInfo objects of type LNKTYPE and SYMTYPE.

==============================
tarfile.TarFile.tarinfo.linkpath
In pax headers, "linkname" is called "linkpath".

==============================
tarfile.TarFile.tarinfo.mode
Permission bits.

==============================
tarfile.TarFile.tarinfo.mtime
Time of last modification.

==============================
tarfile.TarFile.tarinfo.name
Name of the archive member.

==============================
tarfile.TarFile.tarinfo.offset
The tar header starts here.

==============================
tarfile.TarFile.tarinfo.offset_data
The file's data starts here.

==============================
tarfile.TarFile.tarinfo.path
In pax headers, "name" is called "path".

==============================
tarfile.TarFile.tarinfo.pax_headers
A dictionary containing key-value pairs of an associated pax extended header.

==============================
tarfile.TarFile.tarinfo.size
Size in bytes.

==============================
tarfile.TarFile.tarinfo.sparse
Sparse member information.

==============================
tarfile.TarFile.tarinfo.tarfile
None

==============================
tarfile.TarFile.tarinfo.tobuf
(self, format=2, encoding='utf-8', errors='surrogateescape')
Return a tar header as a string of 512 byte blocks.
        

==============================
tarfile.TarFile.tarinfo.type
File type
type is usually one of these constants: REGTYPE, AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, CONTTYPE, CHRTYPE, BLKTYPE, GNUTYPE_SPARSE.

==============================
tarfile.TarFile.tarinfo.uid
User ID of the user who originally stored this member.

==============================
tarfile.TarFile.tarinfo.uname
User name.

==============================
tarfile.TarFile.taropen
(name, mode='r', fileobj=None, **kwargs)
Open uncompressed tar archive name for reading or writing.
        

==============================
tarfile.TarFile.utime
(self, tarinfo, targetpath)
Set modification time of targetpath according to tarinfo.
        

==============================
tarfile.TarFile.xzopen
(name, mode='r', fileobj=None, preset=None, **kwargs)
Open lzma compressed tar archive name for reading or writing.
Appending is not allowed.

==============================
tarfile.TarInfo
(name='')
Informational class which holds the details about an
archive member given by a tar header block.
TarInfo objects are returned by TarFile.getmember(),
TarFile.getmembers() and TarFile.gettarinfo() and are
usually created internally.

==============================
tarfile.TarInfo.chksum
Header checksum.

==============================
tarfile.TarInfo.create_gnu_header
(self, info, encoding, errors)
Return the object as a GNU header block sequence.
        

==============================
tarfile.TarInfo.create_pax_global_header
(pax_headers)
Return the object as a pax global header block sequence.
        

==============================
tarfile.TarInfo.create_pax_header
(self, info, encoding)
Return the object as a ustar header block
If it cannot be
represented this way, prepend a pax extended header sequence
with supplement information.

==============================
tarfile.TarInfo.create_ustar_header
(self, info, encoding, errors)
Return the object as a ustar header block.
        

==============================
tarfile.TarInfo.devmajor
Device major number.

==============================
tarfile.TarInfo.devminor
Device minor number.

==============================
tarfile.TarInfo.frombuf
(buf, encoding, errors)
Construct a TarInfo object from a 512 byte bytes object.
        

==============================
tarfile.TarInfo.fromtarfile
(tarfile)
Return the next TarInfo object from TarFile object
tarfile.

==============================
tarfile.TarInfo.get_info
(self)
Return the TarInfo's attributes as a dictionary.
        

==============================
tarfile.TarInfo.gid
Group ID of the user who originally stored this member.

==============================
tarfile.TarInfo.gname
Group name.

==============================
tarfile.TarInfo.isblk
(self)
Return True if it is a block device.

==============================
tarfile.TarInfo.ischr
(self)
Return True if it is a character device.

==============================
tarfile.TarInfo.isdev
(self)
Return True if it is one of character device, block device or FIFO.

==============================
tarfile.TarInfo.isdir
(self)
Return True if it is a directory.

==============================
tarfile.TarInfo.isfifo
(self)
Return True if it is a FIFO.

==============================
tarfile.TarInfo.isfile
(self)
Return True if the Tarinfo object is a regular file.

==============================
tarfile.TarInfo.islnk
(self)
Return True if it is a hard link.

==============================
tarfile.TarInfo.isreg
(self)
Return True if the Tarinfo object is a regular file.

==============================
tarfile.TarInfo.issparse
(self)
None

==============================
tarfile.TarInfo.issym
(self)
Return True if it is a symbolic link.

==============================
tarfile.TarInfo.linkname
Name of the target file name, which is only present in TarInfo objects of type LNKTYPE and SYMTYPE.

==============================
tarfile.TarInfo.linkpath
In pax headers, "linkname" is called "linkpath".

==============================
tarfile.TarInfo.mode
Permission bits.

==============================
tarfile.TarInfo.mtime
Time of last modification.

==============================
tarfile.TarInfo.name
Name of the archive member.

==============================
tarfile.TarInfo.offset
The tar header starts here.

==============================
tarfile.TarInfo.offset_data
The file's data starts here.

==============================
tarfile.TarInfo.path
In pax headers, "name" is called "path".

==============================
tarfile.TarInfo.pax_headers
A dictionary containing key-value pairs of an associated pax extended header.

==============================
tarfile.TarInfo.size
Size in bytes.

==============================
tarfile.TarInfo.sparse
Sparse member information.

==============================
tarfile.TarInfo.tarfile
None

==============================
tarfile.TarInfo.tobuf
(self, format=2, encoding='utf-8', errors='surrogateescape')
Return a tar header as a string of 512 byte blocks.
        

==============================
tarfile.TarInfo.type
File type
type is usually one of these constants: REGTYPE, AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, CONTTYPE, CHRTYPE, BLKTYPE, GNUTYPE_SPARSE.

==============================
tarfile.TarInfo.uid
User ID of the user who originally stored this member.

==============================
tarfile.TarInfo.uname
User name.

==============================
tarfile.TruncatedHeaderError
Exception for truncated headers.

==============================
tarfile.TruncatedHeaderError.args
None

==============================
tarfile.TruncatedHeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
tarfile.USTAR_FORMAT
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
tarfile.XGLTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.XHDTYPE
bytes(iterable_of_ints) -> bytes
bytes(string, encoding[, errors]) -> bytes
bytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer
bytes(int) -> bytes object of size given by the parameter initialized with null bytes
bytes() -> empty bytes object

Construct an immutable array of bytes from:
  - an iterable yielding integers in range(256)
  - a text string encoded using the specified encoding
  - any object implementing the buffer API.
  - an integer

==============================
tarfile.bltn_open
(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
Open file and return a stream
 Raise OSError upon failure.

file is either a text or byte string giving the name (and the path
if the file isn't in the current working directory) of the file to
be opened or an integer file descriptor of the file to be
wrapped
(If a file descriptor is given, it is closed when the
returned I/O object is closed, unless closefd is set to False.)

mode is an optional string that specifies the mode in which the file
is opened
It defaults to 'r' which means open for reading in text
mode
 Other common values are 'w' for writing (truncating the file if
it already exists), 'x' for creating and writing to a new file, and
'a' for appending (which on some Unix systems, means that all writes
append to the end of the file regardless of the current seek position).
In text mode, if encoding is not specified the encoding used is platform
dependent: locale.getpreferredencoding(False) is called to get the
current locale encoding
(For reading and writing raw bytes use binary
mode and leave encoding unspecified.) The available modes are:

========= ===============================================================
Character Meaning
--------- ---------------------------------------------------------------
'r'       open for reading (default)
'w'       open for writing, truncating the file first
'x'       create a new file and open it for writing
'a'       open for writing, appending to the end of the file if it exists
'b'       binary mode
't'       text mode (default)
'+'       open a disk file for updating (reading and writing)
'U'       universal newline mode (deprecated)
========= ===============================================================

The default mode is 'rt' (open for reading text)
For binary random
access, the mode 'w+b' opens and truncates the file to 0 bytes, while
'r+b' opens the file without truncation
The 'x' mode implies 'w' and
raises an `FileExistsError` if the file already exists.

Python distinguishes between files opened in binary and text modes,
even when the underlying operating system doesn't
Files opened in
binary mode (appending 'b' to the mode argument) return contents as
bytes objects without any decoding
In text mode (the default, or when
't' is appended to the mode argument), the contents of the file are
returned as strings, the bytes having been first decoded using a
platform-dependent encoding or using the specified encoding if given.

'U' mode is deprecated and will raise an exception in future versions
of Python
 It has no effect in Python 3
 Use newline to control
universal newlines mode.

buffering is an optional integer used to set the buffering policy.
Pass 0 to switch buffering off (only allowed in binary mode), 1 to select
line buffering (only usable in text mode), and an integer > 1 to indicate
the size of a fixed-size chunk buffer
 When no buffering argument is
given, the default buffering policy works as follows:

* Binary files are buffered in fixed-size chunks; the size of the buffer
  is chosen using a heuristic trying to determine the underlying device's
  "block size" and falling back on `io.DEFAULT_BUFFER_SIZE`.
  On many systems, the buffer will typically be 4096 or 8192 bytes long.

* "Interactive" text files (files for which isatty() returns True)
  use line buffering
 Other text files use the policy described above
  for binary files.

encoding is the name of the encoding used to decode or encode the
file
This should only be used in text mode
The default encoding is
platform dependent, but any encoding supported by Python can be
passed
 See the codecs module for the list of supported encodings.

errors is an optional string that specifies how encoding errors are to
be handled---this argument should not be used in binary mode
Pass
'strict' to raise a ValueError exception if there is an encoding error
(the default of None has the same effect), or pass 'ignore' to ignore
errors
(Note that ignoring encoding errors can lead to data loss.)
See the documentation for codecs.register or run 'help(codecs.Codec)'
for a list of the permitted encoding error strings.

newline controls how universal newlines works (it only applies to text
mode)
It can be None, '', '\n', '\r', and '\r\n'
 It works as
follows:

* On input, if newline is None, universal newlines mode is
  enabled
Lines in the input can end in '\n', '\r', or '\r\n', and
  these are translated into '\n' before being returned to the
  caller
If it is '', universal newline mode is enabled, but line
  endings are returned to the caller untranslated
If it has any of
  the other legal values, input lines are only terminated by the given
  string, and the line ending is returned to the caller untranslated.

* On output, if newline is None, any '\n' characters written are
  translated to the system default line separator, os.linesep
If
  newline is '' or '\n', no translation takes place
If newline is any
  of the other legal values, any '\n' characters written are translated
  to the given string.

If closefd is False, the underlying file descriptor will be kept open
when the file is closed
This does not work when a file name is given
and must be True in that case.

A custom opener can be used by passing a callable as *opener*
The
underlying file descriptor for the file object is then obtained by
calling *opener* with (*file*, *flags*)
*opener* must return an open
file descriptor (passing os.open as *opener* results in functionality
similar to passing None).

open() returns a file object whose type depends on the mode, and
through which the standard file operations such as reading and writing
are performed
When open() is used to open a file in a text mode ('w',
'r', 'wt', 'rt', etc.), it returns a TextIOWrapper
When used to open
a file in a binary mode, the returned class varies: in read binary
mode, it returns a BufferedReader; in write binary and append binary
modes, it returns a BufferedWriter, and in read/write mode, it returns
a BufferedRandom.

It is also possible to use a string or bytearray as a file for both
reading and writing
For strings StringIO can be used like a file
opened in a text mode, and for bytes a BytesIO can be used like a file
opened in a binary mode.

==============================
tarfile.calc_chksums
(buf)
Calculate the checksum for a member's header by summing up all
characters except for the chksum field which is treated as if
it was filled with spaces
According to the GNU tar sources,
some tars (Sun and NeXT) calculate chksum with signed char,
which will be different if there are chars in the buffer with
the high bit set
So we calculate two checksums, unsigned and
signed.

==============================
tarfile.copy
Generic (shallow and deep) copying operations.

Interface summary:

        import copy

        x = copy.copy(y)        # make a shallow copy of y
        x = copy.deepcopy(y)    # make a deep copy of y

For module specific errors, copy.Error is raised.

The difference between shallow and deep copying is only relevant for
compound objects (objects that contain other objects, like lists or
class instances).

- A shallow copy constructs a new compound object and then (to the
  extent possible) inserts *the same objects* into it that the
  original contains.

- A deep copy constructs a new compound object and then, recursively,
  inserts *copies* into it of the objects found in the original.

Two problems often exist with deep copy operations that don't exist
with shallow copy operations:

 a) recursive objects (compound objects that, directly or indirectly,
    contain a reference to themselves) may cause a recursive loop

 b) because deep copy copies *everything* it may copy too much, e.g.
    administrative data structures that should be shared even between
    copies

Python's deep copy operation avoids these problems by:

 a) keeping a table of objects already copied during the current
    copying pass

 b) letting user-defined classes override the copying operation or the
    set of components copied

This version does not copy types like module, class, function, method,
nor stack trace, stack frame, nor file, socket, window, nor array, nor
any similar types.

Classes can use the same interfaces to control copying that they use
to control pickling: they can define methods called __getinitargs__(),
__getstate__() and __setstate__()
 See the documentation for module
"pickle" for information on these methods.

==============================
tarfile.copyfileobj
(src, dst, length=None, exception=<class 'OSError'>, bufsize=None)
Copy length bytes from fileobj src to fileobj dst.
If length is None, copy the entire content.

==============================
tarfile.grp
Access to the Unix group database.

Group entries are reported as 4-tuples containing the following fields
from the group database, in order:

  gr_name   - name of the group
  gr_passwd - group password (encrypted); often empty
  gr_gid    - numeric ID of the group
  gr_mem    - list of members

The gid is an integer, name and password are strings
 (Note that most
users are not explicitly listed as members of the groups they are in
according to the password database
 Check both databases to get
complete membership information.)

==============================
tarfile.io
The io module provides the Python interfaces to stream handling
The
builtin open function is defined in this module.

At the top of the I/O hierarchy is the abstract base class IOBase
It
defines the basic interface to a stream
Note, however, that there is no
separation between reading and writing to streams; implementations are
allowed to raise an OSError if they do not support a given operation.

Extending IOBase is RawIOBase which deals simply with the reading and
writing of raw bytes to a stream
FileIO subclasses RawIOBase to provide
an interface to OS files.

BufferedIOBase deals with buffering on a raw byte stream (RawIOBase)
Its
subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer
streams that are readable, writable, and both respectively.
BufferedRandom provides a buffered interface to random access
streams
BytesIO is a simple stream of in-memory bytes.

Another IOBase subclass, TextIOBase, deals with the encoding and decoding
of streams into text
TextIOWrapper, which extends it, is a buffered text
interface to a buffered raw stream (`BufferedIOBase`)
Finally, StringIO
is an in-memory stream for text.

Argument names are not part of the specification, and only the arguments
of open() are intended to be used as keyword arguments.

data:

DEFAULT_BUFFER_SIZE

   An int containing the default buffer size used by the module's buffered
   I/O classes
open() uses the file's blksize (as obtained by os.stat) if
   possible.

==============================
tarfile.is_tarfile
(name)
Return True if name points to a tar archive that we
are able to handle, else return False.

==============================
tarfile.itn
(n, digits=8, format=2)
Convert a python number to a number field.
    

==============================
tarfile.main
()
None

==============================
tarfile.nti
(s)
Convert a number field to a python number.
    

==============================
tarfile.nts
(s, encoding, errors)
Convert a null-terminated bytes object to a string.
    

==============================
tarfile.open
(name=None, mode='r', fileobj=None, bufsize=10240, **kwargs)
Open a tar archive for reading, writing or appending
Return
an appropriate TarFile class.

mode:
'r' or 'r:*' open for reading with transparent compression
'r:'         open for reading exclusively uncompressed
'r:gz'       open for reading with gzip compression
'r:bz2'      open for reading with bzip2 compression
'r:xz'       open for reading with lzma compression
'a' or 'a:'  open for appending, creating the file if necessary
'w' or 'w:'  open for writing without compression
'w:gz'       open for writing with gzip compression
'w:bz2'      open for writing with bzip2 compression
'w:xz'       open for writing with lzma compression

'x' or 'x:'  create a tarfile exclusively without compression, raise
             an exception if the file is already created
'x:gz'       create a gzip compressed tarfile, raise an exception
             if the file is already created
'x:bz2'      create a bzip2 compressed tarfile, raise an exception
             if the file is already created
'x:xz'       create an lzma compressed tarfile, raise an exception
             if the file is already created

'r|*'        open a stream of tar blocks with transparent compression
'r|'         open an uncompressed stream of tar blocks for reading
'r|gz'       open a gzip compressed stream of tar blocks
'r|bz2'      open a bzip2 compressed stream of tar blocks
'r|xz'       open an lzma compressed stream of tar blocks
'w|'         open an uncompressed stream for writing
'w|gz'       open a gzip compressed stream for writing
'w|bz2'      open a bzip2 compressed stream for writing
'w|xz'       open an lzma compressed stream for writing

==============================
tarfile.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
tarfile.pwd
This module provides access to the Unix password database.
It is available on all Unix versions.

Password database entries are reported as 7-tuples containing the following
items from the password database (see `<pwd.h>'), in order:
pw_name, pw_passwd, pw_uid, pw_gid, pw_gecos, pw_dir, pw_shell.
The uid and gid items are integers, all others are strings
An
exception is raised if the entry asked for cannot be found.

==============================
tarfile.re
Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl
 It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves
 You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?aiLmsux) The letters set the corresponding flags defined below.
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ..
matches next, but doesn't consume the string.
    (?!...)  Matches if ..
doesn't match next.
    (?<=...) Matches if preceded by ..
(must be fixed length).
    (?<!...) Matches if not preceded by ..
(must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below
 If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9] in
             bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the whole
             range of Unicode digits.
    \D       Matches any non-digit character; equivalent to [^\d].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in
             bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the whole
             range of Unicode whitespace characters.
    \S       Matches any non-whitespace character; equivalent to [^\s].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]
             in bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the
             range of Unicode alphanumeric characters (letters plus digits
             plus underscore).
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match     Match a regular expression pattern to the beginning of a string.
    fullmatch Match a regular expression pattern to all of a string.
    search    Search a string for the presence of a pattern.
    sub       Substitute occurrences of a pattern found in a string.
    subn      Same as sub, but also return the number of substitutions made.
    split     Split a string by the occurrences of a pattern.
    findall   Find all occurrences of a pattern in a string.
    finditer  Return an iterator yielding a Match object for each match.
    compile   Compile a pattern into a Pattern object.
    purge     Clear the regular expression cache.
    escape    Backslash all non-alphanumerics in a string.

Each function other than purge and escape can take an optional 'flags' argument
consisting of one or more of the following module constants, joined by "|".
A, L, and U are mutually exclusive.
    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D
                   match the corresponding ASCII character categories
                   (rather than the whole Unicode categories, which is the
                   default).
                   For bytes patterns, this flag is the only available
                   behaviour and needn't be specified.
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     For compatibility only
Ignored for string patterns (it
                   is the default), and forbidden for bytes patterns.

This module also defines an exception 'error'.

==============================
tarfile.shutil
Utility functions for copying and archiving files and directory trees.

XXX The functions here don't copy the resource fork or other metadata on Mac.

==============================
tarfile.stat
Constants/functions for interpreting results of os.stat() and os.lstat().

Suggested usage: from stat import *

==============================
tarfile.stn
(s, length, encoding, errors)
Convert a string to a null-terminated bytes object.
    

==============================
tarfile.struct
Functions to convert between Python values and C structs.
Python bytes objects are used to hold the data representing the C struct
and also as format strings (explained below) to describe the layout of data
in the C struct.

The optional first format char indicates byte order, size and alignment:
  @: native order, size & alignment (default)
  =: native order, std
size & alignment
  <: little-endian, std
size & alignment
  >: big-endian, std
size & alignment
  !: same as >

The remaining chars indicate types of args and must match exactly;
these can be preceded by a decimal repeat count:
  x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;
  ?: _Bool (requires C99; if not available, char is used instead)
  h:short; H:unsigned short; i:int; I:unsigned int;
  l:long; L:unsigned long; f:float; d:double; e:half-float.
Special cases (preceding decimal count indicates length):
  s:string (array of char); p: pascal string (with count byte).
Special cases (only available in native format):
  n:ssize_t; N:size_t;
  P:an integer type that is wide enough to hold a pointer.
Special case (not in native mode unless 'long long' in platform C):
  q:long long; Q:unsigned long long
Whitespace between formats is ignored.

The variable struct.error is an exception raised on errors.

==============================
tarfile.symlink_exception
Built-in immutable sequence.

If no argument is given, the constructor returns an empty tuple.
If iterable is specified the tuple is initialized from iterable's items.

If the argument is a tuple, the return value is the same object.

==============================
tarfile.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
tarfile.time
This module provides various functions to manipulate time values.

There are two standard representations of time
 One is the number
of seconds since the Epoch, in UTC (a.k.a
GMT)
 It may be an integer
or a floating point number (to represent fractions of seconds).
The Epoch is system-defined; on Unix, it is generally January 1st, 1970.
The actual value can be retrieved by calling gmtime(0).

The other representation is a tuple of 9 integers giving local time.
The tuple items are:
  year (including century, e.g
1998)
  month (1-12)
  day (1-31)
  hours (0-23)
  minutes (0-59)
  seconds (0-59)
  weekday (0-6, Monday is 0)
  Julian day (day in the year, 1-366)
  DST (Daylight Savings Time) flag (-1, 0 or 1)
If the DST flag is 0, the time is given in the regular time zone;
if it is 1, the time is given in the DST time zone;
if it is -1, mktime() should guess based on the date and time.

==============================
tarfile.version
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

