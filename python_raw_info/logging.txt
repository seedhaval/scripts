==============================
logging.BASIC_FORMAT
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.BufferingFormatter
(linefmt=None)
A formatter suitable for formatting a number of records.

==============================
logging.BufferingFormatter.format
(self, records)
Format the specified records and return the result as a string.

==============================
logging.BufferingFormatter.formatFooter
(self, records)
Return the footer string for the specified records.

==============================
logging.BufferingFormatter.formatHeader
(self, records)
Return the header string for the specified records.

==============================
logging.CRITICAL
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.DEBUG
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.ERROR
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.FATAL
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.FileHandler
(filename, mode='a', encoding=None, delay=False)
A handler class which writes formatted logging records to disk files.

==============================
logging.FileHandler.acquire
(self)
Acquire the I/O thread lock.

==============================
logging.FileHandler.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.FileHandler.close
(self)
Closes the stream.

==============================
logging.FileHandler.createLock
(self)
Acquire a thread lock for serializing access to the underlying I/O.

==============================
logging.FileHandler.emit
(self, record)
Emit a record.

If the stream was not opened because 'delay' was specified in the
constructor, open it before calling the superclass's emit.

==============================
logging.FileHandler.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.FileHandler.flush
(self)
Flushes the stream.

==============================
logging.FileHandler.format
(self, record)
Format the specified record.

If a formatter is set, use it
Otherwise, use the default formatter
for the module.

==============================
logging.FileHandler.get_name
(self)
None

==============================
logging.FileHandler.handle
(self, record)
Conditionally emit the specified logging record.

Emission depends on filters which may have been added to the handler.
Wrap the actual emission of the record with acquisition/release of
the I/O thread lock
Returns whether the filter passed the record for
emission.

==============================
logging.FileHandler.handleError
(self, record)
Handle errors which occur during an emit() call.

This method should be called from handlers when an exception is
encountered during an emit() call
If raiseExceptions is false,
exceptions get silently ignored
This is what is mostly wanted
for a logging system - most users will not care about errors in
the logging system, they are more interested in application errors.
You could, however, replace this with a custom handler if you wish.
The record which was being processed is passed in to this method.

==============================
logging.FileHandler.name
None

==============================
logging.FileHandler.release
(self)
Release the I/O thread lock.

==============================
logging.FileHandler.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.FileHandler.setFormatter
(self, fmt)
Set the formatter for this handler.

==============================
logging.FileHandler.setLevel
(self, level)
Set the logging level of this handler
 level must be an int or a str.

==============================
logging.FileHandler.setStream
(self, stream)
Sets the StreamHandler's stream to the specified value,
if it is different.

Returns the old stream, if the stream was changed, or None
if it wasn't.

==============================
logging.FileHandler.set_name
(self, name)
None

==============================
logging.FileHandler.terminator
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.Filter
(name='')
Filter instances are used to perform arbitrary filtering of LogRecords.

Loggers and Handlers can optionally use Filter instances to filter
records as desired
The base filter class only allows events which are
below a certain point in the logger hierarchy
For example, a filter
initialized with "A.B" will allow events logged by loggers "A.B",
"A.B.C", "A.B.C.D", "A.B.D" etc
but not "A.BB", "B.A.B" etc
If
initialized with the empty string, all events are passed.

==============================
logging.Filter.filter
(self, record)
Determine if the specified record is to be logged.

Returns True if the record should be logged, or False otherwise.
If deemed appropriate, the record may be modified in-place.

==============================
logging.Filterer
()
A base class for loggers and handlers which allows them to share
common code.

==============================
logging.Filterer.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.Filterer.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.Filterer.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.Formatter
(fmt=None, datefmt=None, style='%', validate=True)
Formatter instances are used to convert a LogRecord to text.

Formatters need to know how a LogRecord is constructed
They are
responsible for converting a LogRecord to (usually) a string which can
be interpreted by either a human or an external system
The base Formatter
allows a formatting string to be specified
If none is supplied, the
style-dependent default value, "%(message)s", "{message}", or
"${message}", is used.

The Formatter can be initialized with a format string which makes use of
knowledge of the LogRecord attributes - e.g
the default value mentioned
above makes use of the fact that the user's message and arguments are pre-
formatted into a LogRecord's message attribute
Currently, the useful
attributes in a LogRecord are described by:

%(name)s            Name of the logger (logging channel)
%(levelno)s         Numeric logging level for the message (DEBUG, INFO,
                    WARNING, ERROR, CRITICAL)
%(levelname)s       Text logging level for the message ("DEBUG", "INFO",
                    "WARNING", "ERROR", "CRITICAL")
%(pathname)s        Full pathname of the source file where the logging
                    call was issued (if available)
%(filename)s        Filename portion of pathname
%(module)s          Module (name portion of filename)
%(lineno)d          Source line number where the logging call was issued
                    (if available)
%(funcName)s        Function name
%(created)f         Time when the LogRecord was created (time.time()
                    return value)
%(asctime)s         Textual time when the LogRecord was created
%(msecs)d           Millisecond portion of the creation time
%(relativeCreated)d Time in milliseconds when the LogRecord was created,
                    relative to the time the logging module was loaded
                    (typically at application startup time)
%(thread)d          Thread ID (if available)
%(threadName)s      Thread name (if available)
%(process)d         Process ID (if available)
%(message)s         The result of record.getMessage(), computed just as
                    the record is emitted

==============================
logging.Formatter.converter
localtime([seconds]) -> (tm_year,tm_mon,tm_mday,tm_hour,tm_min,
                          tm_sec,tm_wday,tm_yday,tm_isdst)

Convert seconds since the Epoch to a time tuple expressing local time.
When 'seconds' is not passed in, convert the current time instead.

==============================
logging.Formatter.default_msec_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.Formatter.default_time_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.Formatter.format
(self, record)
Format the specified record as text.

The record's attribute dictionary is used as the operand to a
string formatting operation which yields the returned string.
Before formatting the dictionary, a couple of preparatory steps
are carried out
The message attribute of the record is computed
using LogRecord.getMessage()
If the formatting string uses the
time (as determined by a call to usesTime(), formatTime() is
called to format the event time
If there is exception information,
it is formatted using formatException() and appended to the message.

==============================
logging.Formatter.formatException
(self, ei)
Format and return the specified exception information as a string.

This default implementation just uses
traceback.print_exception()

==============================
logging.Formatter.formatMessage
(self, record)
None

==============================
logging.Formatter.formatStack
(self, stack_info)
This method is provided as an extension point for specialized
formatting of stack information.

The input data is a string as returned from a call to
:func:`traceback.print_stack`, but with the last trailing newline
removed.

The base implementation just returns the value passed in.

==============================
logging.Formatter.formatTime
(self, record, datefmt=None)
Return the creation time of the specified LogRecord as formatted text.

This method should be called from format() by a formatter which
wants to make use of a formatted time
This method can be overridden
in formatters to provide for any specific requirement, but the
basic behaviour is as follows: if datefmt (a string) is specified,
it is used with time.strftime() to format the creation time of the
record
Otherwise, an ISO8601-like (or RFC 3339-like) format is used.
The resulting string is returned
This function uses a user-configurable
function to convert the creation time to a tuple
By default,
time.localtime() is used; to change this for a particular formatter
instance, set the 'converter' attribute to a function with the same
signature as time.localtime() or time.gmtime()
To change it for all
formatters, for example if you want all logging times to be shown in GMT,
set the 'converter' attribute in the Formatter class.

==============================
logging.Formatter.usesTime
(self)
Check if the format uses the creation time of the record.

==============================
logging.Handler
(level=0)
Handler instances dispatch logging events to specific destinations.

The base handler class
Acts as a placeholder which defines the Handler
interface
Handlers can optionally use Formatter instances to format
records as desired
By default, no formatter is specified; in this case,
the 'raw' message as determined by record.message is logged.

==============================
logging.Handler.acquire
(self)
Acquire the I/O thread lock.

==============================
logging.Handler.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.Handler.close
(self)
Tidy up any resources used by the handler.

This version removes the handler from an internal map of handlers,
_handlers, which is used for handler lookup by name
Subclasses
should ensure that this gets called from overridden close()
methods.

==============================
logging.Handler.createLock
(self)
Acquire a thread lock for serializing access to the underlying I/O.

==============================
logging.Handler.emit
(self, record)
Do whatever it takes to actually log the specified logging record.

This version is intended to be implemented by subclasses and so
raises a NotImplementedError.

==============================
logging.Handler.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.Handler.flush
(self)
Ensure all logging output has been flushed.

This version does nothing and is intended to be implemented by
subclasses.

==============================
logging.Handler.format
(self, record)
Format the specified record.

If a formatter is set, use it
Otherwise, use the default formatter
for the module.

==============================
logging.Handler.get_name
(self)
None

==============================
logging.Handler.handle
(self, record)
Conditionally emit the specified logging record.

Emission depends on filters which may have been added to the handler.
Wrap the actual emission of the record with acquisition/release of
the I/O thread lock
Returns whether the filter passed the record for
emission.

==============================
logging.Handler.handleError
(self, record)
Handle errors which occur during an emit() call.

This method should be called from handlers when an exception is
encountered during an emit() call
If raiseExceptions is false,
exceptions get silently ignored
This is what is mostly wanted
for a logging system - most users will not care about errors in
the logging system, they are more interested in application errors.
You could, however, replace this with a custom handler if you wish.
The record which was being processed is passed in to this method.

==============================
logging.Handler.name
None

==============================
logging.Handler.release
(self)
Release the I/O thread lock.

==============================
logging.Handler.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.Handler.setFormatter
(self, fmt)
Set the formatter for this handler.

==============================
logging.Handler.setLevel
(self, level)
Set the logging level of this handler
 level must be an int or a str.

==============================
logging.Handler.set_name
(self, name)
None

==============================
logging.INFO
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.LogRecord
(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None, **kwargs)
A LogRecord instance represents an event being logged.

LogRecord instances are created every time something is logged
They
contain all the information pertinent to the event being logged
The
main information passed in is in msg and args, which are combined
using str(msg) % args to create the message field of the record
The
record also includes information such as when the record was created,
the source line where the logging call was made, and any exception
information to be logged.

==============================
logging.LogRecord.getMessage
(self)
Return the message for this LogRecord.

Return the message for this LogRecord after merging any user-supplied
arguments with the message.

==============================
logging.Logger
(name, level=0)
Instances of the Logger class represent a single logging channel
A
"logging channel" indicates an area of an application
Exactly how an
"area" is defined is up to the application developer
Since an
application can have any number of areas, logging channels are identified
by a unique string
Application areas can be nested (e.g
an area
of "input processing" might include sub-areas "read CSV files", "read
XLS files" and "read Gnumeric files")
To cater for this natural nesting,
channel names are organized into a namespace hierarchy where levels are
separated by periods, much like the Java or Python package namespace
So
in the instance given above, channel names might be "input" for the upper
level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.
There is no arbitrary limit to the depth of nesting.

==============================
logging.Logger.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.Logger.addHandler
(self, hdlr)
Add the specified handler to this logger.

==============================
logging.Logger.callHandlers
(self, record)
Pass a record to all relevant handlers.

Loop through all handlers for this logger and its parents in the
logger hierarchy
If no handler was found, output a one-off error
message to sys.stderr
Stop searching up the hierarchy whenever a
logger with the "propagate" attribute set to zero is found - that
will be the last logger whose handlers are called.

==============================
logging.Logger.critical
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'CRITICAL'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.critical("Houston, we have a %s", "major disaster", exc_info=1)

==============================
logging.Logger.debug
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'DEBUG'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)

==============================
logging.Logger.error
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'ERROR'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.error("Houston, we have a %s", "major problem", exc_info=1)

==============================
logging.Logger.exception
(self, msg, *args, exc_info=True, **kwargs)
Convenience method for logging an ERROR with exception information.

==============================
logging.Logger.fatal
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'CRITICAL'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.critical("Houston, we have a %s", "major disaster", exc_info=1)

==============================
logging.Logger.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.Logger.findCaller
(self, stack_info=False, stacklevel=1)
Find the stack frame of the caller so that we can note the source
file name, line number and function name.

==============================
logging.Logger.getChild
(self, suffix)
Get a logger which is a descendant to this one.

This is a convenience method, such that

logging.getLogger('abc').getChild('def.ghi')

is the same as

logging.getLogger('abc.def.ghi')

It's useful, for example, when the parent logger is named using
__name__ rather than a literal string.

==============================
logging.Logger.getEffectiveLevel
(self)
Get the effective level for this logger.

Loop through this logger and its parents in the logger hierarchy,
looking for a non-zero logging level
Return the first one found.

==============================
logging.Logger.handle
(self, record)
Call the handlers for the specified record.

This method is used for unpickled records received from a socket, as
well as those created locally
Logger-level filtering is applied.

==============================
logging.Logger.hasHandlers
(self)
See if this logger has any handlers configured.

Loop through all handlers for this logger and its parents in the
logger hierarchy
Return True if a handler was found, else False.
Stop searching up the hierarchy whenever a logger with the "propagate"
attribute set to zero is found - that will be the last logger which
is checked for the existence of handlers.

==============================
logging.Logger.info
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'INFO'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.info("Houston, we have a %s", "interesting problem", exc_info=1)

==============================
logging.Logger.isEnabledFor
(self, level)
Is this logger enabled for level 'level'?

==============================
logging.Logger.log
(self, level, msg, *args, **kwargs)
Log 'msg % args' with the integer severity 'level'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.log(level, "We have a %s", "mysterious problem", exc_info=1)

==============================
logging.Logger.makeRecord
(self, name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)
A factory method which can be overridden in subclasses to create
specialized LogRecords.

==============================
logging.Logger.manager
There is [under normal circumstances] just one Manager instance, which
holds the hierarchy of loggers.

==============================
logging.Logger.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.Logger.removeHandler
(self, hdlr)
Remove the specified handler from this logger.

==============================
logging.Logger.root
A root logger is not that different to any other logger, except that
it must have a logging level and there is only one instance of it in
the hierarchy.

==============================
logging.Logger.setLevel
(self, level)
Set the logging level of this logger
 level must be an int or a str.

==============================
logging.Logger.warn
(self, msg, *args, **kwargs)
None

==============================
logging.Logger.warning
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'WARNING'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)

==============================
logging.LoggerAdapter
(logger, extra)
An adapter for loggers which makes it easier to specify contextual
information in logging output.

==============================
logging.LoggerAdapter.critical
(self, msg, *args, **kwargs)
Delegate a critical call to the underlying logger.

==============================
logging.LoggerAdapter.debug
(self, msg, *args, **kwargs)
Delegate a debug call to the underlying logger.

==============================
logging.LoggerAdapter.error
(self, msg, *args, **kwargs)
Delegate an error call to the underlying logger.

==============================
logging.LoggerAdapter.exception
(self, msg, *args, exc_info=True, **kwargs)
Delegate an exception call to the underlying logger.

==============================
logging.LoggerAdapter.getEffectiveLevel
(self)
Get the effective level for the underlying logger.

==============================
logging.LoggerAdapter.hasHandlers
(self)
See if the underlying logger has any handlers.

==============================
logging.LoggerAdapter.info
(self, msg, *args, **kwargs)
Delegate an info call to the underlying logger.

==============================
logging.LoggerAdapter.isEnabledFor
(self, level)
Is this logger enabled for level 'level'?

==============================
logging.LoggerAdapter.log
(self, level, msg, *args, **kwargs)
Delegate a log call to the underlying logger, after adding
contextual information from this adapter instance.

==============================
logging.LoggerAdapter.manager
None

==============================
logging.LoggerAdapter.name
None

==============================
logging.LoggerAdapter.process
(self, msg, kwargs)
Process the logging message and keyword arguments passed in to
a logging call to insert contextual information
You can either
manipulate the message itself, the keyword args or both
Return
the message and kwargs modified (or not) to suit your needs.

Normally, you'll only need to override this one method in a
LoggerAdapter subclass for your specific needs.

==============================
logging.LoggerAdapter.setLevel
(self, level)
Set the specified level on the underlying logger.

==============================
logging.LoggerAdapter.warn
(self, msg, *args, **kwargs)
None

==============================
logging.LoggerAdapter.warning
(self, msg, *args, **kwargs)
Delegate a warning call to the underlying logger.

==============================
logging.Manager
(rootnode)
There is [under normal circumstances] just one Manager instance, which
holds the hierarchy of loggers.

==============================
logging.Manager.disable
None

==============================
logging.Manager.getLogger
(self, name)
Get a logger with the specified name (channel name), creating it
if it doesn't yet exist
This name is a dot-separated hierarchical
name, such as "a", "a.b", "a.b.c" or similar.

If a PlaceHolder existed for the specified name [i.e
the logger
didn't exist but a child of it did], replace it with the created
logger and fix up the parent/child references which pointed to the
placeholder to now point to the logger.

==============================
logging.Manager.setLogRecordFactory
(self, factory)
Set the factory to be used when instantiating a log record with this
Manager.

==============================
logging.Manager.setLoggerClass
(self, klass)
Set the class to be used when instantiating a logger with this Manager.

==============================
logging.NOTSET
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.NullHandler
(level=0)
This handler does nothing
It's intended to be used to avoid the
"No handlers could be found for logger XXX" one-off warning
This is
important for library code, which may contain code to log events
If a user
of the library does not configure logging, the one-off warning might be
produced; to avoid this, the library developer simply needs to instantiate
a NullHandler and add it to the top-level logger of the library module or
package.

==============================
logging.NullHandler.acquire
(self)
Acquire the I/O thread lock.

==============================
logging.NullHandler.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.NullHandler.close
(self)
Tidy up any resources used by the handler.

This version removes the handler from an internal map of handlers,
_handlers, which is used for handler lookup by name
Subclasses
should ensure that this gets called from overridden close()
methods.

==============================
logging.NullHandler.createLock
(self)
Acquire a thread lock for serializing access to the underlying I/O.

==============================
logging.NullHandler.emit
(self, record)
Stub.

==============================
logging.NullHandler.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.NullHandler.flush
(self)
Ensure all logging output has been flushed.

This version does nothing and is intended to be implemented by
subclasses.

==============================
logging.NullHandler.format
(self, record)
Format the specified record.

If a formatter is set, use it
Otherwise, use the default formatter
for the module.

==============================
logging.NullHandler.get_name
(self)
None

==============================
logging.NullHandler.handle
(self, record)
Stub.

==============================
logging.NullHandler.handleError
(self, record)
Handle errors which occur during an emit() call.

This method should be called from handlers when an exception is
encountered during an emit() call
If raiseExceptions is false,
exceptions get silently ignored
This is what is mostly wanted
for a logging system - most users will not care about errors in
the logging system, they are more interested in application errors.
You could, however, replace this with a custom handler if you wish.
The record which was being processed is passed in to this method.

==============================
logging.NullHandler.name
None

==============================
logging.NullHandler.release
(self)
Release the I/O thread lock.

==============================
logging.NullHandler.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.NullHandler.setFormatter
(self, fmt)
Set the formatter for this handler.

==============================
logging.NullHandler.setLevel
(self, level)
Set the logging level of this handler
 level must be an int or a str.

==============================
logging.NullHandler.set_name
(self, name)
None

==============================
logging.PercentStyle
(fmt)
None

==============================
logging.PercentStyle.asctime_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.PercentStyle.asctime_search
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.PercentStyle.default_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.PercentStyle.format
(self, record)
None

==============================
logging.PercentStyle.usesTime
(self)
None

==============================
logging.PercentStyle.validate
(self)
Validate the input format, ensure it matches the correct style

==============================
logging.PercentStyle.validation_pattern
Compiled regular expression object.

==============================
logging.PlaceHolder
(alogger)
PlaceHolder instances are used in the Manager logger hierarchy to take
the place of nodes for which no loggers have been defined
This class is
intended for internal use only and not as part of the public API.

==============================
logging.PlaceHolder.append
(self, alogger)
Add the specified logger as a child of this placeholder.

==============================
logging.RootLogger
(level)
A root logger is not that different to any other logger, except that
it must have a logging level and there is only one instance of it in
the hierarchy.

==============================
logging.RootLogger.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.RootLogger.addHandler
(self, hdlr)
Add the specified handler to this logger.

==============================
logging.RootLogger.callHandlers
(self, record)
Pass a record to all relevant handlers.

Loop through all handlers for this logger and its parents in the
logger hierarchy
If no handler was found, output a one-off error
message to sys.stderr
Stop searching up the hierarchy whenever a
logger with the "propagate" attribute set to zero is found - that
will be the last logger whose handlers are called.

==============================
logging.RootLogger.critical
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'CRITICAL'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.critical("Houston, we have a %s", "major disaster", exc_info=1)

==============================
logging.RootLogger.debug
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'DEBUG'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)

==============================
logging.RootLogger.error
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'ERROR'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.error("Houston, we have a %s", "major problem", exc_info=1)

==============================
logging.RootLogger.exception
(self, msg, *args, exc_info=True, **kwargs)
Convenience method for logging an ERROR with exception information.

==============================
logging.RootLogger.fatal
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'CRITICAL'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.critical("Houston, we have a %s", "major disaster", exc_info=1)

==============================
logging.RootLogger.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.RootLogger.findCaller
(self, stack_info=False, stacklevel=1)
Find the stack frame of the caller so that we can note the source
file name, line number and function name.

==============================
logging.RootLogger.getChild
(self, suffix)
Get a logger which is a descendant to this one.

This is a convenience method, such that

logging.getLogger('abc').getChild('def.ghi')

is the same as

logging.getLogger('abc.def.ghi')

It's useful, for example, when the parent logger is named using
__name__ rather than a literal string.

==============================
logging.RootLogger.getEffectiveLevel
(self)
Get the effective level for this logger.

Loop through this logger and its parents in the logger hierarchy,
looking for a non-zero logging level
Return the first one found.

==============================
logging.RootLogger.handle
(self, record)
Call the handlers for the specified record.

This method is used for unpickled records received from a socket, as
well as those created locally
Logger-level filtering is applied.

==============================
logging.RootLogger.hasHandlers
(self)
See if this logger has any handlers configured.

Loop through all handlers for this logger and its parents in the
logger hierarchy
Return True if a handler was found, else False.
Stop searching up the hierarchy whenever a logger with the "propagate"
attribute set to zero is found - that will be the last logger which
is checked for the existence of handlers.

==============================
logging.RootLogger.info
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'INFO'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.info("Houston, we have a %s", "interesting problem", exc_info=1)

==============================
logging.RootLogger.isEnabledFor
(self, level)
Is this logger enabled for level 'level'?

==============================
logging.RootLogger.log
(self, level, msg, *args, **kwargs)
Log 'msg % args' with the integer severity 'level'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.log(level, "We have a %s", "mysterious problem", exc_info=1)

==============================
logging.RootLogger.makeRecord
(self, name, level, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)
A factory method which can be overridden in subclasses to create
specialized LogRecords.

==============================
logging.RootLogger.manager
There is [under normal circumstances] just one Manager instance, which
holds the hierarchy of loggers.

==============================
logging.RootLogger.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.RootLogger.removeHandler
(self, hdlr)
Remove the specified handler from this logger.

==============================
logging.RootLogger.root
A root logger is not that different to any other logger, except that
it must have a logging level and there is only one instance of it in
the hierarchy.

==============================
logging.RootLogger.setLevel
(self, level)
Set the logging level of this logger
 level must be an int or a str.

==============================
logging.RootLogger.warn
(self, msg, *args, **kwargs)
None

==============================
logging.RootLogger.warning
(self, msg, *args, **kwargs)
Log 'msg % args' with severity 'WARNING'.

To pass exception information, use the keyword argument exc_info with
a true value, e.g.

logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)

==============================
logging.StrFormatStyle
(fmt)
None

==============================
logging.StrFormatStyle.asctime_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StrFormatStyle.asctime_search
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StrFormatStyle.default_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StrFormatStyle.field_spec
Compiled regular expression object.

==============================
logging.StrFormatStyle.fmt_spec
Compiled regular expression object.

==============================
logging.StrFormatStyle.format
(self, record)
None

==============================
logging.StrFormatStyle.usesTime
(self)
None

==============================
logging.StrFormatStyle.validate
(self)
Validate the input format, ensure it is the correct string formatting style

==============================
logging.StrFormatStyle.validation_pattern
Compiled regular expression object.

==============================
logging.StreamHandler
(stream=None)
A handler class which writes logging records, appropriately formatted,
to a stream
Note that this class does not close the stream, as
sys.stdout or sys.stderr may be used.

==============================
logging.StreamHandler.acquire
(self)
Acquire the I/O thread lock.

==============================
logging.StreamHandler.addFilter
(self, filter)
Add the specified filter to this handler.

==============================
logging.StreamHandler.close
(self)
Tidy up any resources used by the handler.

This version removes the handler from an internal map of handlers,
_handlers, which is used for handler lookup by name
Subclasses
should ensure that this gets called from overridden close()
methods.

==============================
logging.StreamHandler.createLock
(self)
Acquire a thread lock for serializing access to the underlying I/O.

==============================
logging.StreamHandler.emit
(self, record)
Emit a record.

If a formatter is specified, it is used to format the record.
The record is then written to the stream with a trailing newline
 If
exception information is present, it is formatted using
traceback.print_exception and appended to the stream
 If the stream
has an 'encoding' attribute, it is used to determine how to do the
output to the stream.

==============================
logging.StreamHandler.filter
(self, record)
Determine if a record is loggable by consulting all the filters.

The default is to allow the record to be logged; any filter can veto
this and the record is then dropped
Returns a zero value if a record
is to be dropped, else non-zero.

.
versionchanged:: 3.2

   Allow filters to be just callables.

==============================
logging.StreamHandler.flush
(self)
Flushes the stream.

==============================
logging.StreamHandler.format
(self, record)
Format the specified record.

If a formatter is set, use it
Otherwise, use the default formatter
for the module.

==============================
logging.StreamHandler.get_name
(self)
None

==============================
logging.StreamHandler.handle
(self, record)
Conditionally emit the specified logging record.

Emission depends on filters which may have been added to the handler.
Wrap the actual emission of the record with acquisition/release of
the I/O thread lock
Returns whether the filter passed the record for
emission.

==============================
logging.StreamHandler.handleError
(self, record)
Handle errors which occur during an emit() call.

This method should be called from handlers when an exception is
encountered during an emit() call
If raiseExceptions is false,
exceptions get silently ignored
This is what is mostly wanted
for a logging system - most users will not care about errors in
the logging system, they are more interested in application errors.
You could, however, replace this with a custom handler if you wish.
The record which was being processed is passed in to this method.

==============================
logging.StreamHandler.name
None

==============================
logging.StreamHandler.release
(self)
Release the I/O thread lock.

==============================
logging.StreamHandler.removeFilter
(self, filter)
Remove the specified filter from this handler.

==============================
logging.StreamHandler.setFormatter
(self, fmt)
Set the formatter for this handler.

==============================
logging.StreamHandler.setLevel
(self, level)
Set the logging level of this handler
 level must be an int or a str.

==============================
logging.StreamHandler.setStream
(self, stream)
Sets the StreamHandler's stream to the specified value,
if it is different.

Returns the old stream, if the stream was changed, or None
if it wasn't.

==============================
logging.StreamHandler.set_name
(self, name)
None

==============================
logging.StreamHandler.terminator
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StringTemplateStyle
(fmt)
None

==============================
logging.StringTemplateStyle.asctime_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StringTemplateStyle.asctime_search
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StringTemplateStyle.default_format
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.StringTemplateStyle.format
(self, record)
None

==============================
logging.StringTemplateStyle.usesTime
(self)
None

==============================
logging.StringTemplateStyle.validate
(self)
Validate the input format, ensure it matches the correct style

==============================
logging.StringTemplateStyle.validation_pattern
Compiled regular expression object.

==============================
logging.Template
(template)
A string class for supporting $-substitutions.

==============================
logging.Template.braceidpattern
None

==============================
logging.Template.delimiter
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.Template.flags
An enumeration.

==============================
logging.Template.idpattern
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
logging.Template.pattern
Compiled regular expression object.

==============================
logging.Template.safe_substitute
(self, mapping={}, /, **kws)
None

==============================
logging.Template.substitute
(self, mapping={}, /, **kws)
None

==============================
logging.WARN
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.WARNING
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
logging.addLevelName
(level, levelName)
Associate 'levelName' with 'level'.

This is used when converting levels to text during message formatting.

==============================
logging.atexit
allow programmer to define multiple exit functions to be executedupon normal program termination.

Two public functions, register and unregister, are defined.

==============================
logging.basicConfig
(**kwargs)
Do basic configuration for the logging system.

This function does nothing if the root logger already has handlers
configured, unless the keyword argument *force* is set to ``True``.
It is a convenience method intended for use by simple scripts
to do one-shot configuration of the logging package.

The default behaviour is to create a StreamHandler which writes to
sys.stderr, set a formatter using the BASIC_FORMAT format string, and
add the handler to the root logger.

A number of optional keyword arguments may be specified, which can alter
the default behaviour.

filename  Specifies that a FileHandler be created, using the specified
          filename, rather than a StreamHandler.
filemode  Specifies the mode to open the file, if filename is specified
          (if filemode is unspecified, it defaults to 'a').
format    Use the specified format string for the handler.
datefmt   Use the specified date/time format.
style     If a format string is specified, use this to specify the
          type of format string (possible values '%', '{', '$', for
          %-formatting, :meth:`str.format` and :class:`string.Template`
          - defaults to '%').
level     Set the root logger level to the specified level.
stream    Use the specified stream to initialize the StreamHandler
Note
          that this argument is incompatible with 'filename' - if both
          are present, 'stream' is ignored.
handlers  If specified, this should be an iterable of already created
          handlers, which will be added to the root handler
Any handler
          in the list which does not have a formatter assigned will be
          assigned the formatter created in this function.
force     If this keyword  is specified as true, any existing handlers
          attached to the root logger are removed and closed, before
          carrying out the configuration as specified by the other
          arguments.
Note that you could specify a stream created using open(filename, mode)
rather than passing the filename and mode in
However, it should be
remembered that StreamHandler does not close its stream (since it may be
using sys.stdout or sys.stderr), whereas FileHandler closes its stream
when the handler is closed.

.
versionchanged:: 3.8
   Added the ``force`` parameter.

.
versionchanged:: 3.2
   Added the ``style`` parameter.

.
versionchanged:: 3.3
   Added the ``handlers`` parameter
A ``ValueError`` is now thrown for
   incompatible arguments (e.g
``handlers`` specified together with
   ``filename``/``filemode``, or ``filename``/``filemode`` specified
   together with ``stream``, or ``handlers`` specified together with
   ``stream``.

==============================
logging.captureWarnings
(capture)
If capture is true, redirect all warnings to the logging package.
If capture is False, ensure that warnings are not redirected to logging
but to their original destinations.

==============================
logging.collections
This module implements specialized container datatypes providing
alternatives to Python's general purpose built-in containers, dict,
list, set, and tuple.

* namedtuple   factory function for creating tuple subclasses with named fields
* deque        list-like container with fast appends and pops on either end
* ChainMap     dict-like class for creating a single view of multiple mappings
* Counter      dict subclass for counting hashable objects
* OrderedDict  dict subclass that remembers the order entries were added
* defaultdict  dict subclass that calls a factory function to supply missing values
* UserDict     wrapper around dictionary objects for easier dict subclassing
* UserList     wrapper around list objects for easier list subclassing
* UserString   wrapper around string objects for easier string subclassing

==============================
logging.critical
(msg, *args, **kwargs)
Log a message with severity 'CRITICAL' on the root logger
If the logger
has no handlers, call basicConfig() to add a console handler with a
pre-defined format.

==============================
logging.currentframe
()
None

==============================
logging.debug
(msg, *args, **kwargs)
Log a message with severity 'DEBUG' on the root logger
If the logger has
no handlers, call basicConfig() to add a console handler with a pre-defined
format.

==============================
logging.disable
(level=50)
Disable all logging calls of severity 'level' and below.

==============================
logging.error
(msg, *args, **kwargs)
Log a message with severity 'ERROR' on the root logger
If the logger has
no handlers, call basicConfig() to add a console handler with a pre-defined
format.

==============================
logging.exception
(msg, *args, exc_info=True, **kwargs)
Log a message with severity 'ERROR' on the root logger, with exception
information
If the logger has no handlers, basicConfig() is called to add
a console handler with a pre-defined format.

==============================
logging.fatal
(msg, *args, **kwargs)
Log a message with severity 'CRITICAL' on the root logger
If the logger
has no handlers, call basicConfig() to add a console handler with a
pre-defined format.

==============================
logging.getLevelName
(level)
Return the textual or numeric representation of logging level 'level'.

If the level is one of the predefined levels (CRITICAL, ERROR, WARNING,
INFO, DEBUG) then you get the corresponding string
If you have
associated levels with names using addLevelName then the name you have
associated with 'level' is returned.

If a numeric value corresponding to one of the defined levels is passed
in, the corresponding string representation is returned.

If a string representation of the level is passed in, the corresponding
numeric value is returned.

If no matching numeric or string value is passed in, the string
'Level %s' % level is returned.

==============================
logging.getLogRecordFactory
()
Return the factory to be used when instantiating a log record.

==============================
logging.getLogger
(name=None)
Return a logger with the specified name, creating it if necessary.

If no name is specified, return the root logger.

==============================
logging.getLoggerClass
()
Return the class to be used when instantiating a logger.

==============================
logging.info
(msg, *args, **kwargs)
Log a message with severity 'INFO' on the root logger
If the logger has
no handlers, call basicConfig() to add a console handler with a pre-defined
format.

==============================
logging.io
The io module provides the Python interfaces to stream handling
The
builtin open function is defined in this module.

At the top of the I/O hierarchy is the abstract base class IOBase
It
defines the basic interface to a stream
Note, however, that there is no
separation between reading and writing to streams; implementations are
allowed to raise an OSError if they do not support a given operation.

Extending IOBase is RawIOBase which deals simply with the reading and
writing of raw bytes to a stream
FileIO subclasses RawIOBase to provide
an interface to OS files.

BufferedIOBase deals with buffering on a raw byte stream (RawIOBase)
Its
subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer
streams that are readable, writable, and both respectively.
BufferedRandom provides a buffered interface to random access
streams
BytesIO is a simple stream of in-memory bytes.

Another IOBase subclass, TextIOBase, deals with the encoding and decoding
of streams into text
TextIOWrapper, which extends it, is a buffered text
interface to a buffered raw stream (`BufferedIOBase`)
Finally, StringIO
is an in-memory stream for text.

Argument names are not part of the specification, and only the arguments
of open() are intended to be used as keyword arguments.

data:

DEFAULT_BUFFER_SIZE

   An int containing the default buffer size used by the module's buffered
   I/O classes
open() uses the file's blksize (as obtained by os.stat) if
   possible.

==============================
logging.lastResort
This class is like a StreamHandler using sys.stderr, but always uses
whatever sys.stderr is currently set to rather than the value of
sys.stderr at handler construction time.

==============================
logging.log
(level, msg, *args, **kwargs)
Log 'msg % args' with the integer severity 'level' on the root logger
If
the logger has no handlers, call basicConfig() to add a console handler
with a pre-defined format.

==============================
logging.logMultiprocessing
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

==============================
logging.logProcesses
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

==============================
logging.logThreads
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

==============================
logging.makeLogRecord
(dict)
Make a LogRecord whose attributes are defined by the specified dictionary,
This function is useful for converting a logging event received over
a socket connection (which is sent as a dictionary) into a LogRecord
instance.

==============================
logging.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
logging.raiseExceptions
bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

==============================
logging.re
Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl
 It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves
 You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?aiLmsux) The letters set the corresponding flags defined below.
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ..
matches next, but doesn't consume the string.
    (?!...)  Matches if ..
doesn't match next.
    (?<=...) Matches if preceded by ..
(must be fixed length).
    (?<!...) Matches if not preceded by ..
(must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below
 If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9] in
             bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the whole
             range of Unicode digits.
    \D       Matches any non-digit character; equivalent to [^\d].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in
             bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the whole
             range of Unicode whitespace characters.
    \S       Matches any non-whitespace character; equivalent to [^\s].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]
             in bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the
             range of Unicode alphanumeric characters (letters plus digits
             plus underscore).
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match     Match a regular expression pattern to the beginning of a string.
    fullmatch Match a regular expression pattern to all of a string.
    search    Search a string for the presence of a pattern.
    sub       Substitute occurrences of a pattern found in a string.
    subn      Same as sub, but also return the number of substitutions made.
    split     Split a string by the occurrences of a pattern.
    findall   Find all occurrences of a pattern in a string.
    finditer  Return an iterator yielding a Match object for each match.
    compile   Compile a pattern into a Pattern object.
    purge     Clear the regular expression cache.
    escape    Backslash all non-alphanumerics in a string.

Each function other than purge and escape can take an optional 'flags' argument
consisting of one or more of the following module constants, joined by "|".
A, L, and U are mutually exclusive.
    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D
                   match the corresponding ASCII character categories
                   (rather than the whole Unicode categories, which is the
                   default).
                   For bytes patterns, this flag is the only available
                   behaviour and needn't be specified.
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     For compatibility only
Ignored for string patterns (it
                   is the default), and forbidden for bytes patterns.

This module also defines an exception 'error'.

==============================
logging.root
A root logger is not that different to any other logger, except that
it must have a logging level and there is only one instance of it in
the hierarchy.

==============================
logging.setLogRecordFactory
(factory)
Set the factory to be used when instantiating a log record.

:param factory: A callable which will be called to instantiate
a log record.

==============================
logging.setLoggerClass
(klass)
Set the class to be used when instantiating a logger
The class should
define __init__() such that only a name argument is required, and the
__init__() should call Logger.__init__()

==============================
logging.shutdown
(handlerList=[<weakref at 0x7fb7145629a0; to '_StderrHandler' at 0x7fb714556910>])
Perform any cleanup actions in the logging system (e.g
flushing
buffers).

Should be called at application exit.

==============================
logging.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
logging.threading
Thread module emulating a subset of Java's threading model.

==============================
logging.time
This module provides various functions to manipulate time values.

There are two standard representations of time
 One is the number
of seconds since the Epoch, in UTC (a.k.a
GMT)
 It may be an integer
or a floating point number (to represent fractions of seconds).
The Epoch is system-defined; on Unix, it is generally January 1st, 1970.
The actual value can be retrieved by calling gmtime(0).

The other representation is a tuple of 9 integers giving local time.
The tuple items are:
  year (including century, e.g
1998)
  month (1-12)
  day (1-31)
  hours (0-23)
  minutes (0-59)
  seconds (0-59)
  weekday (0-6, Monday is 0)
  Julian day (day in the year, 1-366)
  DST (Daylight Savings Time) flag (-1, 0 or 1)
If the DST flag is 0, the time is given in the regular time zone;
if it is 1, the time is given in the DST time zone;
if it is -1, mktime() should guess based on the date and time.

==============================
logging.traceback
Extract, format and print information about Python stack traces.

==============================
logging.warn
(msg, *args, **kwargs)
None

==============================
logging.warning
(msg, *args, **kwargs)
Log a message with severity 'WARNING' on the root logger
If the logger has
no handlers, call basicConfig() to add a console handler with a pre-defined
format.

==============================
logging.warnings
Python part of the warnings subsystem.

==============================
logging.weakref
Weak reference support for Python.

This module is an implementation of PEP 205:

http://www.python.org/dev/peps/pep-0205/

