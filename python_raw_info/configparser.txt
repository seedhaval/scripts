==============================
configparser.BasicInterpolation
()
Interpolation as implemented in the classic ConfigParser.

The option values can contain format strings which refer to other values in
the same section, or values in the special default section.

For example:

    something: %(dir)s/whatever

would resolve the "%(dir)s" to the value of dir
 All reference
expansions are done late, on demand
If a user needs to use a bare % in
a configuration file, she can escape it by writing %%
Other % usage
is considered a user error and raises `InterpolationSyntaxError'.

==============================
configparser.BasicInterpolation.before_get
(self, parser, section, option, value, defaults)
None

==============================
configparser.BasicInterpolation.before_read
(self, parser, section, option, value)
None

==============================
configparser.BasicInterpolation.before_set
(self, parser, section, option, value)
None

==============================
configparser.BasicInterpolation.before_write
(self, parser, section, option, value)
None

==============================
configparser.ConfigParser
(defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f5f0e4f1f40>, converters=<object object at 0x7f5f0e4f1f40>)
ConfigParser implementing interpolation.

==============================
configparser.ConfigParser.BOOLEAN_STATES
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
configparser.ConfigParser.NONSPACECRE
Compiled regular expression object.

==============================
configparser.ConfigParser.OPTCRE
Compiled regular expression object.

==============================
configparser.ConfigParser.OPTCRE_NV
Compiled regular expression object.

==============================
configparser.ConfigParser.SECTCRE
Compiled regular expression object.

==============================
configparser.ConfigParser.add_section
(self, section)
Create a new section in the configuration
 Extends
RawConfigParser.add_section by validating if the section name is
a string.

==============================
configparser.ConfigParser.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
configparser.ConfigParser.converters
None

==============================
configparser.ConfigParser.defaults
(self)
None

==============================
configparser.ConfigParser.get
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>)
Get an option value for a given section.

If `vars' is provided, it must be a dictionary
The option is looked up
in `vars' (if provided), `section', and in `DEFAULTSECT' in that order.
If the key is not found and `fallback' is provided, it is used as
a fallback value
`None' can be provided as a `fallback' value.

If interpolation is enabled and the optional argument `raw' is False,
all interpolations are expanded in the return values.

Arguments `raw', `vars', and `fallback' are keyword only.

The section DEFAULT is special.

==============================
configparser.ConfigParser.getboolean
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.ConfigParser.getfloat
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.ConfigParser.getint
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.ConfigParser.has_option
(self, section, option)
Check for the existence of a given option in a given section.
If the specified `section' is None or an empty string, DEFAULT is
assumed
If the specified `section' does not exist, returns False.

==============================
configparser.ConfigParser.has_section
(self, section)
Indicate whether the named section is present in the configuration.

The DEFAULT section is not acknowledged.

==============================
configparser.ConfigParser.items
(self, section=<object object at 0x7f5f0e4f1f40>, raw=False, vars=None)
Return a list of (name, value) tuples for each option in a section.

All % interpolations are expanded in the return values, based on the
defaults passed into the constructor, unless the optional argument
`raw' is true
 Additional substitutions may be provided using the
`vars' argument, which must be a dictionary whose contents overrides
any pre-existing defaults.

The section DEFAULT is special.

==============================
configparser.ConfigParser.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
configparser.ConfigParser.options
(self, section)
Return a list of option names for the given section name.

==============================
configparser.ConfigParser.optionxform
(self, optionstr)
None

==============================
configparser.ConfigParser.pop
(self, key, default=<object object at 0x7f5f0e4f1160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
configparser.ConfigParser.popitem
(self)
Remove a section from the parser and return it as
a (section_name, section_proxy) tuple
If no section is present, raise
KeyError.

The section DEFAULT is never returned because it cannot be removed.

==============================
configparser.ConfigParser.read
(self, filenames, encoding=None)
Read and parse a filename or an iterable of filenames.

Files that cannot be opened are silently ignored; this is
designed so that you can specify an iterable of potential
configuration file locations (e.g
current directory, user's
home directory, systemwide directory), and all existing
configuration files in the iterable will be read
 A single
filename may also be given.

Return list of successfully read files.

==============================
configparser.ConfigParser.read_dict
(self, dictionary, source='<dict>')
Read configuration from a dictionary.

Keys are section names, values are dictionaries with keys and values
that should be present in the section
If the used dictionary type
preserves order, sections and their keys will be added in order.

All types held in the dictionary are converted to strings during
reading, including section names, option names and keys.

Optional second argument is the `source' specifying the name of the
dictionary being read.

==============================
configparser.ConfigParser.read_file
(self, f, source=None)
Like read() but the argument must be a file-like object.

The `f' argument must be iterable, returning one line at a time.
Optional second argument is the `source' specifying the name of the
file being read
If not given, it is taken from f.name
If `f' has no
`name' attribute, `<???>' is used.

==============================
configparser.ConfigParser.read_string
(self, string, source='<string>')
Read configuration from a given string.

==============================
configparser.ConfigParser.readfp
(self, fp, filename=None)
Deprecated, use read_file instead.

==============================
configparser.ConfigParser.remove_option
(self, section, option)
Remove an option.

==============================
configparser.ConfigParser.remove_section
(self, section)
Remove a file section.

==============================
configparser.ConfigParser.sections
(self)
Return a list of section names, excluding [DEFAULT]

==============================
configparser.ConfigParser.set
(self, section, option, value=None)
Set an option
 Extends RawConfigParser.set by validating type and
interpolation syntax on the value.

==============================
configparser.ConfigParser.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
configparser.ConfigParser.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
configparser.ConfigParser.values
(self)
D.values() -> an object providing a view on D's values

==============================
configparser.ConfigParser.write
(self, fp, space_around_delimiters=True)
Write an .ini-format representation of the configuration state.

If `space_around_delimiters' is True (the default), delimiters
between keys and values are surrounded by spaces.

==============================
configparser.ConverterMapping
(parser)
Enables reuse of get*() methods between the parser and section proxies.

If a parser class implements a getter directly, the value for the given
key will be ``None``
The presence of the converter name here enables
section proxies to find and use the implementation on the parser class.

==============================
configparser.ConverterMapping.GETTERCRE
Compiled regular expression object.

==============================
configparser.ConverterMapping.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
configparser.ConverterMapping.get
(self, key, default=None)
D.get(k[,d]) -> D[k] if k in D, else d
 d defaults to None.

==============================
configparser.ConverterMapping.items
(self)
D.items() -> a set-like object providing a view on D's items

==============================
configparser.ConverterMapping.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
configparser.ConverterMapping.pop
(self, key, default=<object object at 0x7f5f0e4f1160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
configparser.ConverterMapping.popitem
(self)
D.popitem() -> (k, v), remove and return some (key, value) pair
as a 2-tuple; but raise KeyError if D is empty.

==============================
configparser.ConverterMapping.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
configparser.ConverterMapping.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
configparser.ConverterMapping.values
(self)
D.values() -> an object providing a view on D's values

==============================
configparser.DEFAULTSECT
str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object
If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

==============================
configparser.DuplicateOptionError
(section, option, source=None, lineno=None)
Raised by strict parsers when an option is repeated in an input source.

Current implementation raises this exception only when an option is found
more than once in a single file, string or dictionary.

==============================
configparser.DuplicateOptionError.args
None

==============================
configparser.DuplicateOptionError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.DuplicateSectionError
(section, source=None, lineno=None)
Raised when a section is repeated in an input source.

Possible repetitions that raise this exception are: multiple creation
using the API or in strict parsers when a section is found more than once
in a single input file, string or dictionary.

==============================
configparser.DuplicateSectionError.args
None

==============================
configparser.DuplicateSectionError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.Error
(msg='')
Base class for ConfigParser exceptions.

==============================
configparser.Error.args
None

==============================
configparser.Error.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.ExtendedInterpolation
()
Advanced variant of interpolation, supports the syntax used by
`zc.buildout'
Enables interpolation between sections.

==============================
configparser.ExtendedInterpolation.before_get
(self, parser, section, option, value, defaults)
None

==============================
configparser.ExtendedInterpolation.before_read
(self, parser, section, option, value)
None

==============================
configparser.ExtendedInterpolation.before_set
(self, parser, section, option, value)
None

==============================
configparser.ExtendedInterpolation.before_write
(self, parser, section, option, value)
None

==============================
configparser.Interpolation
()
Dummy interpolation that passes the value through with no changes.

==============================
configparser.Interpolation.before_get
(self, parser, section, option, value, defaults)
None

==============================
configparser.Interpolation.before_read
(self, parser, section, option, value)
None

==============================
configparser.Interpolation.before_set
(self, parser, section, option, value)
None

==============================
configparser.Interpolation.before_write
(self, parser, section, option, value)
None

==============================
configparser.InterpolationDepthError
(option, section, rawval)
Raised when substitutions are nested too deeply.

==============================
configparser.InterpolationDepthError.args
None

==============================
configparser.InterpolationDepthError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.InterpolationError
(option, section, msg)
Base class for interpolation-related exceptions.

==============================
configparser.InterpolationError.args
None

==============================
configparser.InterpolationError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.InterpolationMissingOptionError
(option, section, rawval, reference)
A string substitution required a setting which was not available.

==============================
configparser.InterpolationMissingOptionError.args
None

==============================
configparser.InterpolationMissingOptionError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.InterpolationSyntaxError
(option, section, msg)
Raised when the source text contains invalid syntax.

Current implementation raises this exception when the source text into
which substitutions are made does not conform to the required syntax.

==============================
configparser.InterpolationSyntaxError.args
None

==============================
configparser.InterpolationSyntaxError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.LegacyInterpolation
()
Deprecated interpolation used in old versions of ConfigParser.
Use BasicInterpolation or ExtendedInterpolation instead.

==============================
configparser.LegacyInterpolation.before_get
(self, parser, section, option, value, vars)
None

==============================
configparser.LegacyInterpolation.before_read
(self, parser, section, option, value)
None

==============================
configparser.LegacyInterpolation.before_set
(self, parser, section, option, value)
None

==============================
configparser.LegacyInterpolation.before_write
(self, parser, section, option, value)
None

==============================
configparser.MAX_INTERPOLATION_DEPTH
int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given
 If x is a number, return x.__int__()
 For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base
 The literal can be preceded by '+' or '-' and be surrounded
by whitespace
 The base defaults to 10
 Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

==============================
configparser.MissingSectionHeaderError
(filename, lineno, line)
Raised when a key-value pair is found before any section header.

==============================
configparser.MissingSectionHeaderError.append
(self, lineno, line)
None

==============================
configparser.MissingSectionHeaderError.args
None

==============================
configparser.MissingSectionHeaderError.filename
Deprecated, use `source'.

==============================
configparser.MissingSectionHeaderError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.MutableMapping
()
None

==============================
configparser.MutableMapping.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
configparser.MutableMapping.get
(self, key, default=None)
D.get(k[,d]) -> D[k] if k in D, else d
 d defaults to None.

==============================
configparser.MutableMapping.items
(self)
D.items() -> a set-like object providing a view on D's items

==============================
configparser.MutableMapping.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
configparser.MutableMapping.pop
(self, key, default=<object object at 0x7f5f0e4f1160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
configparser.MutableMapping.popitem
(self)
D.popitem() -> (k, v), remove and return some (key, value) pair
as a 2-tuple; but raise KeyError if D is empty.

==============================
configparser.MutableMapping.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
configparser.MutableMapping.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
configparser.MutableMapping.values
(self)
D.values() -> an object providing a view on D's values

==============================
configparser.NoOptionError
(option, section)
A requested option was not found.

==============================
configparser.NoOptionError.args
None

==============================
configparser.NoOptionError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.NoSectionError
(section)
Raised when no section matches a requested option.

==============================
configparser.NoSectionError.args
None

==============================
configparser.NoSectionError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.ParsingError
(source=None, filename=None)
Raised when a configuration file does not follow legal syntax.

==============================
configparser.ParsingError.append
(self, lineno, line)
None

==============================
configparser.ParsingError.args
None

==============================
configparser.ParsingError.filename
Deprecated, use `source'.

==============================
configparser.ParsingError.with_traceback
Exception.with_traceback(tb) --
set self.__traceback__ to tb and return self.

==============================
configparser.RawConfigParser
(defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x7f5f0e4f1f40>, converters=<object object at 0x7f5f0e4f1f40>)
ConfigParser that does not do interpolation.

==============================
configparser.RawConfigParser.BOOLEAN_STATES
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
configparser.RawConfigParser.NONSPACECRE
Compiled regular expression object.

==============================
configparser.RawConfigParser.OPTCRE
Compiled regular expression object.

==============================
configparser.RawConfigParser.OPTCRE_NV
Compiled regular expression object.

==============================
configparser.RawConfigParser.SECTCRE
Compiled regular expression object.

==============================
configparser.RawConfigParser.add_section
(self, section)
Create a new section in the configuration.

Raise DuplicateSectionError if a section by the specified name
already exists
Raise ValueError if name is DEFAULT.

==============================
configparser.RawConfigParser.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
configparser.RawConfigParser.converters
None

==============================
configparser.RawConfigParser.defaults
(self)
None

==============================
configparser.RawConfigParser.get
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>)
Get an option value for a given section.

If `vars' is provided, it must be a dictionary
The option is looked up
in `vars' (if provided), `section', and in `DEFAULTSECT' in that order.
If the key is not found and `fallback' is provided, it is used as
a fallback value
`None' can be provided as a `fallback' value.

If interpolation is enabled and the optional argument `raw' is False,
all interpolations are expanded in the return values.

Arguments `raw', `vars', and `fallback' are keyword only.

The section DEFAULT is special.

==============================
configparser.RawConfigParser.getboolean
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.RawConfigParser.getfloat
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.RawConfigParser.getint
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.RawConfigParser.has_option
(self, section, option)
Check for the existence of a given option in a given section.
If the specified `section' is None or an empty string, DEFAULT is
assumed
If the specified `section' does not exist, returns False.

==============================
configparser.RawConfigParser.has_section
(self, section)
Indicate whether the named section is present in the configuration.

The DEFAULT section is not acknowledged.

==============================
configparser.RawConfigParser.items
(self, section=<object object at 0x7f5f0e4f1f40>, raw=False, vars=None)
Return a list of (name, value) tuples for each option in a section.

All % interpolations are expanded in the return values, based on the
defaults passed into the constructor, unless the optional argument
`raw' is true
 Additional substitutions may be provided using the
`vars' argument, which must be a dictionary whose contents overrides
any pre-existing defaults.

The section DEFAULT is special.

==============================
configparser.RawConfigParser.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
configparser.RawConfigParser.options
(self, section)
Return a list of option names for the given section name.

==============================
configparser.RawConfigParser.optionxform
(self, optionstr)
None

==============================
configparser.RawConfigParser.pop
(self, key, default=<object object at 0x7f5f0e4f1160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
configparser.RawConfigParser.popitem
(self)
Remove a section from the parser and return it as
a (section_name, section_proxy) tuple
If no section is present, raise
KeyError.

The section DEFAULT is never returned because it cannot be removed.

==============================
configparser.RawConfigParser.read
(self, filenames, encoding=None)
Read and parse a filename or an iterable of filenames.

Files that cannot be opened are silently ignored; this is
designed so that you can specify an iterable of potential
configuration file locations (e.g
current directory, user's
home directory, systemwide directory), and all existing
configuration files in the iterable will be read
 A single
filename may also be given.

Return list of successfully read files.

==============================
configparser.RawConfigParser.read_dict
(self, dictionary, source='<dict>')
Read configuration from a dictionary.

Keys are section names, values are dictionaries with keys and values
that should be present in the section
If the used dictionary type
preserves order, sections and their keys will be added in order.

All types held in the dictionary are converted to strings during
reading, including section names, option names and keys.

Optional second argument is the `source' specifying the name of the
dictionary being read.

==============================
configparser.RawConfigParser.read_file
(self, f, source=None)
Like read() but the argument must be a file-like object.

The `f' argument must be iterable, returning one line at a time.
Optional second argument is the `source' specifying the name of the
file being read
If not given, it is taken from f.name
If `f' has no
`name' attribute, `<???>' is used.

==============================
configparser.RawConfigParser.read_string
(self, string, source='<string>')
Read configuration from a given string.

==============================
configparser.RawConfigParser.readfp
(self, fp, filename=None)
Deprecated, use read_file instead.

==============================
configparser.RawConfigParser.remove_option
(self, section, option)
Remove an option.

==============================
configparser.RawConfigParser.remove_section
(self, section)
Remove a file section.

==============================
configparser.RawConfigParser.sections
(self)
Return a list of section names, excluding [DEFAULT]

==============================
configparser.RawConfigParser.set
(self, section, option, value=None)
Set an option.

==============================
configparser.RawConfigParser.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
configparser.RawConfigParser.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
configparser.RawConfigParser.values
(self)
D.values() -> an object providing a view on D's values

==============================
configparser.RawConfigParser.write
(self, fp, space_around_delimiters=True)
Write an .ini-format representation of the configuration state.

If `space_around_delimiters' is True (the default), delimiters
between keys and values are surrounded by spaces.

==============================
configparser.SafeConfigParser
(*args, **kwargs)
ConfigParser alias for backwards compatibility purposes.

==============================
configparser.SafeConfigParser.BOOLEAN_STATES
dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list
 For example:  dict(one=1, two=2)

==============================
configparser.SafeConfigParser.NONSPACECRE
Compiled regular expression object.

==============================
configparser.SafeConfigParser.OPTCRE
Compiled regular expression object.

==============================
configparser.SafeConfigParser.OPTCRE_NV
Compiled regular expression object.

==============================
configparser.SafeConfigParser.SECTCRE
Compiled regular expression object.

==============================
configparser.SafeConfigParser.add_section
(self, section)
Create a new section in the configuration
 Extends
RawConfigParser.add_section by validating if the section name is
a string.

==============================
configparser.SafeConfigParser.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
configparser.SafeConfigParser.converters
None

==============================
configparser.SafeConfigParser.defaults
(self)
None

==============================
configparser.SafeConfigParser.get
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>)
Get an option value for a given section.

If `vars' is provided, it must be a dictionary
The option is looked up
in `vars' (if provided), `section', and in `DEFAULTSECT' in that order.
If the key is not found and `fallback' is provided, it is used as
a fallback value
`None' can be provided as a `fallback' value.

If interpolation is enabled and the optional argument `raw' is False,
all interpolations are expanded in the return values.

Arguments `raw', `vars', and `fallback' are keyword only.

The section DEFAULT is special.

==============================
configparser.SafeConfigParser.getboolean
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.SafeConfigParser.getfloat
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.SafeConfigParser.getint
(self, section, option, *, raw=False, vars=None, fallback=<object object at 0x7f5f0e4f1f40>, **kwargs)
None

==============================
configparser.SafeConfigParser.has_option
(self, section, option)
Check for the existence of a given option in a given section.
If the specified `section' is None or an empty string, DEFAULT is
assumed
If the specified `section' does not exist, returns False.

==============================
configparser.SafeConfigParser.has_section
(self, section)
Indicate whether the named section is present in the configuration.

The DEFAULT section is not acknowledged.

==============================
configparser.SafeConfigParser.items
(self, section=<object object at 0x7f5f0e4f1f40>, raw=False, vars=None)
Return a list of (name, value) tuples for each option in a section.

All % interpolations are expanded in the return values, based on the
defaults passed into the constructor, unless the optional argument
`raw' is true
 Additional substitutions may be provided using the
`vars' argument, which must be a dictionary whose contents overrides
any pre-existing defaults.

The section DEFAULT is special.

==============================
configparser.SafeConfigParser.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
configparser.SafeConfigParser.options
(self, section)
Return a list of option names for the given section name.

==============================
configparser.SafeConfigParser.optionxform
(self, optionstr)
None

==============================
configparser.SafeConfigParser.pop
(self, key, default=<object object at 0x7f5f0e4f1160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
configparser.SafeConfigParser.popitem
(self)
Remove a section from the parser and return it as
a (section_name, section_proxy) tuple
If no section is present, raise
KeyError.

The section DEFAULT is never returned because it cannot be removed.

==============================
configparser.SafeConfigParser.read
(self, filenames, encoding=None)
Read and parse a filename or an iterable of filenames.

Files that cannot be opened are silently ignored; this is
designed so that you can specify an iterable of potential
configuration file locations (e.g
current directory, user's
home directory, systemwide directory), and all existing
configuration files in the iterable will be read
 A single
filename may also be given.

Return list of successfully read files.

==============================
configparser.SafeConfigParser.read_dict
(self, dictionary, source='<dict>')
Read configuration from a dictionary.

Keys are section names, values are dictionaries with keys and values
that should be present in the section
If the used dictionary type
preserves order, sections and their keys will be added in order.

All types held in the dictionary are converted to strings during
reading, including section names, option names and keys.

Optional second argument is the `source' specifying the name of the
dictionary being read.

==============================
configparser.SafeConfigParser.read_file
(self, f, source=None)
Like read() but the argument must be a file-like object.

The `f' argument must be iterable, returning one line at a time.
Optional second argument is the `source' specifying the name of the
file being read
If not given, it is taken from f.name
If `f' has no
`name' attribute, `<???>' is used.

==============================
configparser.SafeConfigParser.read_string
(self, string, source='<string>')
Read configuration from a given string.

==============================
configparser.SafeConfigParser.readfp
(self, fp, filename=None)
Deprecated, use read_file instead.

==============================
configparser.SafeConfigParser.remove_option
(self, section, option)
Remove an option.

==============================
configparser.SafeConfigParser.remove_section
(self, section)
Remove a file section.

==============================
configparser.SafeConfigParser.sections
(self)
Return a list of section names, excluding [DEFAULT]

==============================
configparser.SafeConfigParser.set
(self, section, option, value=None)
Set an option
 Extends RawConfigParser.set by validating type and
interpolation syntax on the value.

==============================
configparser.SafeConfigParser.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
configparser.SafeConfigParser.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
configparser.SafeConfigParser.values
(self)
D.values() -> an object providing a view on D's values

==============================
configparser.SafeConfigParser.write
(self, fp, space_around_delimiters=True)
Write an .ini-format representation of the configuration state.

If `space_around_delimiters' is True (the default), delimiters
between keys and values are surrounded by spaces.

==============================
configparser.SectionProxy
(parser, name)
A proxy for a single section from a parser.

==============================
configparser.SectionProxy.clear
(self)
D.clear() -> None
 Remove all items from D.

==============================
configparser.SectionProxy.get
(self, option, fallback=None, *, raw=False, vars=None, _impl=None, **kwargs)
Get an option value.

Unless `fallback` is provided, `None` will be returned if the option
is not found.

==============================
configparser.SectionProxy.items
(self)
D.items() -> a set-like object providing a view on D's items

==============================
configparser.SectionProxy.keys
(self)
D.keys() -> a set-like object providing a view on D's keys

==============================
configparser.SectionProxy.name
None

==============================
configparser.SectionProxy.parser
None

==============================
configparser.SectionProxy.pop
(self, key, default=<object object at 0x7f5f0e4f1160>)
D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised.

==============================
configparser.SectionProxy.popitem
(self)
D.popitem() -> (k, v), remove and return some (key, value) pair
as a 2-tuple; but raise KeyError if D is empty.

==============================
configparser.SectionProxy.setdefault
(self, key, default=None)
D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D

==============================
configparser.SectionProxy.update
(self, other=(), /, **kwds)
D.update([E, ]**F) -> None
 Update D from mapping/iterable E and F.
If E present and has a .keys() method, does:     for k in E: D[k] = E[k]
If E present and lacks .keys() method, does:     for (k, v) in E: D[k] = v
In either case, this is followed by: for k, v in F.items(): D[k] = v

==============================
configparser.SectionProxy.values
(self)
D.values() -> an object providing a view on D's values

==============================
configparser.functools
functools.py - Tools for working with functions and callable objects

==============================
configparser.io
The io module provides the Python interfaces to stream handling
The
builtin open function is defined in this module.

At the top of the I/O hierarchy is the abstract base class IOBase
It
defines the basic interface to a stream
Note, however, that there is no
separation between reading and writing to streams; implementations are
allowed to raise an OSError if they do not support a given operation.

Extending IOBase is RawIOBase which deals simply with the reading and
writing of raw bytes to a stream
FileIO subclasses RawIOBase to provide
an interface to OS files.

BufferedIOBase deals with buffering on a raw byte stream (RawIOBase)
Its
subclasses, BufferedWriter, BufferedReader, and BufferedRWPair buffer
streams that are readable, writable, and both respectively.
BufferedRandom provides a buffered interface to random access
streams
BytesIO is a simple stream of in-memory bytes.

Another IOBase subclass, TextIOBase, deals with the encoding and decoding
of streams into text
TextIOWrapper, which extends it, is a buffered text
interface to a buffered raw stream (`BufferedIOBase`)
Finally, StringIO
is an in-memory stream for text.

Argument names are not part of the specification, and only the arguments
of open() are intended to be used as keyword arguments.

data:

DEFAULT_BUFFER_SIZE

   An int containing the default buffer size used by the module's buffered
   I/O classes
open() uses the file's blksize (as obtained by os.stat) if
   possible.

==============================
configparser.itertools
Functional tools for creating and using iterators.

Infinite iterators:
count(start=0, step=1) --> start, start+step, start+2*step, ...
cycle(p) --> p0, p1, ..
plast, p0, p1, ...
repeat(elem [,n]) --> elem, elem, elem, ..
endlessly or up to n times

Iterators terminating on the shortest input sequence:
accumulate(p[, func]) --> p0, p0+p1, p0+p1+p2
chain(p, q, ...) --> p0, p1, ..
plast, q0, q1, ...
chain.from_iterable([p, q, ...]) --> p0, p1, ..
plast, q0, q1, ...
compress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]), ...
dropwhile(pred, seq) --> seq[n], seq[n+1], starting when pred fails
groupby(iterable[, keyfunc]) --> sub-iterators grouped by value of keyfunc(v)
filterfalse(pred, seq) --> elements of seq where pred(elem) is False
islice(seq, [start,] stop [, step]) --> elements from
       seq[start:stop:step]
starmap(fun, seq) --> fun(*seq[0]), fun(*seq[1]), ...
tee(it, n=2) --> (it1, it2 , ..
itn) splits one iterator into n
takewhile(pred, seq) --> seq[0], seq[1], until pred fails
zip_longest(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ...

Combinatoric generators:
product(p, q, ..
[repeat=1]) --> cartesian product
permutations(p[, r])
combinations(p, r)
combinations_with_replacement(p, r)

==============================
configparser.os
OS routines for NT or Posix depending on what system we're on.

This exports:
  - all functions from posix or nt, e.g
unlink, stat, etc.
  - os.path is either posixpath or ntpath
  - os.name is either 'posix' or 'nt'
  - os.curdir is a string representing the current directory (always '.')
  - os.pardir is a string representing the parent directory (always '..')
  - os.sep is the (or a most common) pathname separator ('/' or '\\')
  - os.extsep is the extension separator (always '.')
  - os.altsep is the alternate pathname separator (None or '/')
  - os.pathsep is the component separator used in $PATH etc
  - os.linesep is the line separator in text files ('\r' or '\n' or '\r\n')
  - os.defpath is the default search path for executables
  - os.devnull is the file path of the null device ('/dev/null', etc.)

Programs that import and use 'os' stand a better chance of being
portable between different platforms
 Of course, they must then
only use functions that are defined by all platforms (e.g., unlink
and opendir), and leave all pathname manipulation to os.path
(e.g., split and join).

==============================
configparser.re
Support for regular expressions (RE).

This module provides regular expression matching operations similar to
those found in Perl
 It supports both 8-bit and Unicode strings; both
the pattern and the strings being processed can contain null bytes and
characters outside the US ASCII range.

Regular expressions can contain both special and ordinary characters.
Most ordinary characters, like "A", "a", or "0", are the simplest
regular expressions; they simply match themselves
 You can
concatenate ordinary characters, so last matches the string 'last'.

The special characters are:
    "."      Matches any character except a newline.
    "^"      Matches the start of the string.
    "$"      Matches the end of the string or just before the newline at
             the end of the string.
    "*"      Matches 0 or more (greedy) repetitions of the preceding RE.
             Greedy means that it will match as many repetitions as possible.
    "+"      Matches 1 or more (greedy) repetitions of the preceding RE.
    "?"      Matches 0 or 1 (greedy) of the preceding RE.
    *?,+?,?? Non-greedy versions of the previous three special characters.
    {m,n}    Matches from m to n repetitions of the preceding RE.
    {m,n}?   Non-greedy version of the above.
    "\\"     Either escapes special characters or signals a special sequence.
    []       Indicates a set of characters.
             A "^" as the first character indicates a complementing set.
    "|"      A|B, creates an RE that will match either A or B.
    (...)    Matches the RE inside the parentheses.
             The contents can be retrieved or matched later in the string.
    (?aiLmsux) The letters set the corresponding flags defined below.
    (?:...)  Non-grouping version of regular parentheses.
    (?P<name>...) The substring matched by the group is accessible by name.
    (?P=name)     Matches the text matched earlier by the group named name.
    (?#...)  A comment; ignored.
    (?=...)  Matches if ..
matches next, but doesn't consume the string.
    (?!...)  Matches if ..
doesn't match next.
    (?<=...) Matches if preceded by ..
(must be fixed length).
    (?<!...) Matches if not preceded by ..
(must be fixed length).
    (?(id/name)yes|no) Matches yes pattern if the group with id/name matched,
                       the (optional) no pattern otherwise.

The special sequences consist of "\\" and a character from the list
below
 If the ordinary character is not on the list, then the
resulting RE will match the second character.
    \number  Matches the contents of the group of the same number.
    \A       Matches only at the start of the string.
    \Z       Matches only at the end of the string.
    \b       Matches the empty string, but only at the start or end of a word.
    \B       Matches the empty string, but not at the start or end of a word.
    \d       Matches any decimal digit; equivalent to the set [0-9] in
             bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the whole
             range of Unicode digits.
    \D       Matches any non-digit character; equivalent to [^\d].
    \s       Matches any whitespace character; equivalent to [ \t\n\r\f\v] in
             bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the whole
             range of Unicode whitespace characters.
    \S       Matches any non-whitespace character; equivalent to [^\s].
    \w       Matches any alphanumeric character; equivalent to [a-zA-Z0-9_]
             in bytes patterns or string patterns with the ASCII flag.
             In string patterns without the ASCII flag, it will match the
             range of Unicode alphanumeric characters (letters plus digits
             plus underscore).
             With LOCALE, it will match the set [0-9_] plus characters defined
             as letters for the current locale.
    \W       Matches the complement of \w.
    \\       Matches a literal backslash.

This module exports the following functions:
    match     Match a regular expression pattern to the beginning of a string.
    fullmatch Match a regular expression pattern to all of a string.
    search    Search a string for the presence of a pattern.
    sub       Substitute occurrences of a pattern found in a string.
    subn      Same as sub, but also return the number of substitutions made.
    split     Split a string by the occurrences of a pattern.
    findall   Find all occurrences of a pattern in a string.
    finditer  Return an iterator yielding a Match object for each match.
    compile   Compile a pattern into a Pattern object.
    purge     Clear the regular expression cache.
    escape    Backslash all non-alphanumerics in a string.

Each function other than purge and escape can take an optional 'flags' argument
consisting of one or more of the following module constants, joined by "|".
A, L, and U are mutually exclusive.
    A  ASCII       For string patterns, make \w, \W, \b, \B, \d, \D
                   match the corresponding ASCII character categories
                   (rather than the whole Unicode categories, which is the
                   default).
                   For bytes patterns, this flag is the only available
                   behaviour and needn't be specified.
    I  IGNORECASE  Perform case-insensitive matching.
    L  LOCALE      Make \w, \W, \b, \B, dependent on the current locale.
    M  MULTILINE   "^" matches the beginning of lines (after a newline)
                   as well as the string.
                   "$" matches the end of lines (before a newline) as well
                   as the end of the string.
    S  DOTALL      "." matches any character at all, including the newline.
    X  VERBOSE     Ignore whitespace and comments for nicer looking RE's.
    U  UNICODE     For compatibility only
Ignored for string patterns (it
                   is the default), and forbidden for bytes patterns.

This module also defines an exception 'error'.

==============================
configparser.sys
This module provides access to some objects used or maintained by the
interpreter and to functions that interact strongly with the interpreter.

Dynamic objects:

argv -- command line arguments; argv[0] is the script pathname if known
path -- module search path; path[0] is the script directory, else ''
modules -- dictionary of loaded modules

displayhook -- called to show results in an interactive session
excepthook -- called to handle any uncaught exception other than SystemExit
  To customize printing in an interactive session or to install a custom
  top-level exception handler, assign other functions to replace these.

stdin -- standard input file object; used by input()
stdout -- standard output file object; used by print()
stderr -- standard error object; used for error messages
  By assigning other file objects (or objects that behave like files)
  to these, it is possible to redirect all of the interpreter's I/O.

last_type -- type of last uncaught exception
last_value -- value of last uncaught exception
last_traceback -- traceback of last uncaught exception
  These three are only available in an interactive session after a
  traceback has been printed.

Static objects:

builtin_module_names -- tuple of module names built into this interpreter
copyright -- copyright notice pertaining to this interpreter
exec_prefix -- prefix used to find the machine-specific Python library
executable -- absolute path of the executable binary of the Python interpreter
float_info -- a named tuple with information about the float implementation.
float_repr_style -- string indicating the style of repr() output for floats
hash_info -- a named tuple with information about the hash algorithm.
hexversion -- version information encoded as a single integer
implementation -- Python implementation information.
int_info -- a named tuple with information about the int implementation.
maxsize -- the largest supported length of containers.
maxunicode -- the value of the largest Unicode code point
platform -- platform identifier
prefix -- prefix used to find the Python library
thread_info -- a named tuple with information about the thread implementation.
version -- the version of this interpreter as a string
version_info -- version information as a named tuple
__stdin__ -- the original stdin; don't touch!
__stdout__ -- the original stdout; don't touch!
__stderr__ -- the original stderr; don't touch!
__displayhook__ -- the original displayhook; don't touch!
__excepthook__ -- the original excepthook; don't touch!

Functions:

displayhook() -- print an object to the screen, and save it in builtins._
excepthook() -- print an exception and its traceback to sys.stderr
exc_info() -- return thread-safe information about the current exception
exit() -- exit the interpreter by raising SystemExit
getdlopenflags() -- returns flags to be used for dlopen() calls
getprofile() -- get the global profiling function
getrefcount() -- return the reference count for an object (plus one :-)
getrecursionlimit() -- return the max recursion depth for the interpreter
getsizeof() -- return the size of an object in bytes
gettrace() -- get the global debug tracing function
setcheckinterval() -- control how often the interpreter checks for events
setdlopenflags() -- set the flags to be used for dlopen() calls
setprofile() -- set the global profiling function
setrecursionlimit() -- set the max recursion depth for the interpreter
settrace() -- set the global debug tracing function

==============================
configparser.warnings
Python part of the warnings subsystem.

